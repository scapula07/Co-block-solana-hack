{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;\nconst sdpTransform = __importStar(require(\"sdp-transform\"));\n/**\n * This function must be called with an SDP with 1 m=audio and 1 m=video\n * sections.\n */\nfunction extractRtpCapabilities(_ref) {\n  let {\n    sdpObject\n  } = _ref;\n  // Map of RtpCodecParameters indexed by payload type.\n  const codecsMap = new Map();\n  // Array of RtpHeaderExtensions.\n  const headerExtensions = [];\n  // Whether a m=audio/video section has been already found.\n  let gotAudio = false;\n  let gotVideo = false;\n  for (const m of sdpObject.media) {\n    const kind = m.type;\n    switch (kind) {\n      case 'audio':\n        {\n          if (gotAudio) continue;\n          gotAudio = true;\n          break;\n        }\n      case 'video':\n        {\n          if (gotVideo) continue;\n          gotVideo = true;\n          break;\n        }\n      default:\n        {\n          continue;\n        }\n    }\n    // Get codecs.\n    for (const rtp of m.rtp) {\n      const codec = {\n        kind: kind,\n        mimeType: `${kind}/${rtp.codec}`,\n        preferredPayloadType: rtp.payload,\n        clockRate: rtp.rate,\n        channels: rtp.encoding,\n        parameters: {},\n        rtcpFeedback: []\n      };\n      codecsMap.set(codec.preferredPayloadType, codec);\n    }\n    // Get codec parameters.\n    for (const fmtp of m.fmtp || []) {\n      const parameters = sdpTransform.parseParams(fmtp.config);\n      const codec = codecsMap.get(fmtp.payload);\n      if (!codec) continue;\n      // Specials case to convert parameter value to string.\n      if (parameters && parameters.hasOwnProperty('profile-level-id')) parameters['profile-level-id'] = String(parameters['profile-level-id']);\n      codec.parameters = parameters;\n    }\n    // Get RTCP feedback for each codec.\n    for (const fb of m.rtcpFb || []) {\n      const feedback = {\n        type: fb.type,\n        parameter: fb.subtype\n      };\n      if (!feedback.parameter) delete feedback.parameter;\n      // rtcp-fb payload is not '*', so just apply it to its corresponding\n      // codec.\n      if (fb.payload !== '*') {\n        const codec = codecsMap.get(fb.payload);\n        if (!codec) continue;\n        codec.rtcpFeedback.push(feedback);\n      }\n      // If rtcp-fb payload is '*' it must be applied to all codecs with same\n      // kind (with some exceptions such as RTX codec).\n      else {\n        for (const codec of codecsMap.values()) {\n          if (codec.kind === kind && !/.+\\/rtx$/i.test(codec.mimeType)) {\n            codec.rtcpFeedback.push(feedback);\n          }\n        }\n      }\n    }\n    // Get RTP header extensions.\n    for (const ext of m.ext || []) {\n      // Ignore encrypted extensions (not yet supported in mediasoup).\n      if (ext['encrypt-uri']) continue;\n      const headerExtension = {\n        kind: kind,\n        uri: ext.uri,\n        preferredId: ext.value\n      };\n      headerExtensions.push(headerExtension);\n    }\n  }\n  const rtpCapabilities = {\n    codecs: Array.from(codecsMap.values()),\n    headerExtensions: headerExtensions\n  };\n  return rtpCapabilities;\n}\nexports.extractRtpCapabilities = extractRtpCapabilities;\nfunction extractDtlsParameters(_ref2) {\n  let {\n    sdpObject\n  } = _ref2;\n  const mediaObject = (sdpObject.media || []).find(m => m.iceUfrag && m.port !== 0);\n  if (!mediaObject) throw new Error('no active media section found');\n  const fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;\n  let role;\n  switch (mediaObject.setup) {\n    case 'active':\n      role = 'client';\n      break;\n    case 'passive':\n      role = 'server';\n      break;\n    case 'actpass':\n      role = 'auto';\n      break;\n  }\n  const dtlsParameters = {\n    role,\n    fingerprints: [{\n      algorithm: fingerprint.type,\n      value: fingerprint.hash\n    }]\n  };\n  return dtlsParameters;\n}\nexports.extractDtlsParameters = extractDtlsParameters;\nfunction getCname(_ref3) {\n  let {\n    offerMediaObject\n  } = _ref3;\n  const ssrcCnameLine = (offerMediaObject.ssrcs || []).find(line => line.attribute === 'cname');\n  if (!ssrcCnameLine) return '';\n  return ssrcCnameLine.value;\n}\nexports.getCname = getCname;\n/**\n * Apply codec parameters in the given SDP m= section answer based on the\n * given RTP parameters of an offer.\n */\nfunction applyCodecParameters(_ref4) {\n  let {\n    offerRtpParameters,\n    answerMediaObject\n  } = _ref4;\n  for (const codec of offerRtpParameters.codecs) {\n    const mimeType = codec.mimeType.toLowerCase();\n    // Avoid parsing codec parameters for unhandled codecs.\n    if (mimeType !== 'audio/opus') continue;\n    const rtp = (answerMediaObject.rtp || []).find(r => r.payload === codec.payloadType);\n    if (!rtp) continue;\n    // Just in case.\n    answerMediaObject.fmtp = answerMediaObject.fmtp || [];\n    let fmtp = answerMediaObject.fmtp.find(f => f.payload === codec.payloadType);\n    if (!fmtp) {\n      fmtp = {\n        payload: codec.payloadType,\n        config: ''\n      };\n      answerMediaObject.fmtp.push(fmtp);\n    }\n    const parameters = sdpTransform.parseParams(fmtp.config);\n    switch (mimeType) {\n      case 'audio/opus':\n        {\n          const spropStereo = codec.parameters['sprop-stereo'];\n          if (spropStereo !== undefined) parameters.stereo = spropStereo ? 1 : 0;\n          break;\n        }\n    }\n    // Write the codec fmtp.config back.\n    fmtp.config = '';\n    for (const key of Object.keys(parameters)) {\n      if (fmtp.config) fmtp.config += ';';\n      fmtp.config += `${key}=${parameters[key]}`;\n    }\n  }\n}\nexports.applyCodecParameters = applyCodecParameters;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","applyCodecParameters","getCname","extractDtlsParameters","extractRtpCapabilities","sdpTransform","require","sdpObject","codecsMap","Map","headerExtensions","gotAudio","gotVideo","media","kind","type","rtp","codec","mimeType","preferredPayloadType","payload","clockRate","rate","channels","encoding","parameters","rtcpFeedback","set","fmtp","parseParams","config","String","fb","rtcpFb","feedback","parameter","subtype","push","values","test","ext","headerExtension","uri","preferredId","rtpCapabilities","codecs","Array","from","mediaObject","find","iceUfrag","port","Error","fingerprint","role","setup","dtlsParameters","fingerprints","algorithm","hash","offerMediaObject","ssrcCnameLine","ssrcs","line","attribute","offerRtpParameters","answerMediaObject","toLowerCase","r","payloadType","f","spropStereo","stereo","key","keys"],"sources":["/Users/user/Desktop/solana-hack-1/client/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;\nconst sdpTransform = __importStar(require(\"sdp-transform\"));\n/**\n * This function must be called with an SDP with 1 m=audio and 1 m=video\n * sections.\n */\nfunction extractRtpCapabilities({ sdpObject }) {\n    // Map of RtpCodecParameters indexed by payload type.\n    const codecsMap = new Map();\n    // Array of RtpHeaderExtensions.\n    const headerExtensions = [];\n    // Whether a m=audio/video section has been already found.\n    let gotAudio = false;\n    let gotVideo = false;\n    for (const m of sdpObject.media) {\n        const kind = m.type;\n        switch (kind) {\n            case 'audio':\n                {\n                    if (gotAudio)\n                        continue;\n                    gotAudio = true;\n                    break;\n                }\n            case 'video':\n                {\n                    if (gotVideo)\n                        continue;\n                    gotVideo = true;\n                    break;\n                }\n            default:\n                {\n                    continue;\n                }\n        }\n        // Get codecs.\n        for (const rtp of m.rtp) {\n            const codec = {\n                kind: kind,\n                mimeType: `${kind}/${rtp.codec}`,\n                preferredPayloadType: rtp.payload,\n                clockRate: rtp.rate,\n                channels: rtp.encoding,\n                parameters: {},\n                rtcpFeedback: []\n            };\n            codecsMap.set(codec.preferredPayloadType, codec);\n        }\n        // Get codec parameters.\n        for (const fmtp of m.fmtp || []) {\n            const parameters = sdpTransform.parseParams(fmtp.config);\n            const codec = codecsMap.get(fmtp.payload);\n            if (!codec)\n                continue;\n            // Specials case to convert parameter value to string.\n            if (parameters && parameters.hasOwnProperty('profile-level-id'))\n                parameters['profile-level-id'] = String(parameters['profile-level-id']);\n            codec.parameters = parameters;\n        }\n        // Get RTCP feedback for each codec.\n        for (const fb of m.rtcpFb || []) {\n            const feedback = {\n                type: fb.type,\n                parameter: fb.subtype\n            };\n            if (!feedback.parameter)\n                delete feedback.parameter;\n            // rtcp-fb payload is not '*', so just apply it to its corresponding\n            // codec.\n            if (fb.payload !== '*') {\n                const codec = codecsMap.get(fb.payload);\n                if (!codec)\n                    continue;\n                codec.rtcpFeedback.push(feedback);\n            }\n            // If rtcp-fb payload is '*' it must be applied to all codecs with same\n            // kind (with some exceptions such as RTX codec).\n            else {\n                for (const codec of codecsMap.values()) {\n                    if (codec.kind === kind && !/.+\\/rtx$/i.test(codec.mimeType)) {\n                        codec.rtcpFeedback.push(feedback);\n                    }\n                }\n            }\n        }\n        // Get RTP header extensions.\n        for (const ext of m.ext || []) {\n            // Ignore encrypted extensions (not yet supported in mediasoup).\n            if (ext['encrypt-uri'])\n                continue;\n            const headerExtension = {\n                kind: kind,\n                uri: ext.uri,\n                preferredId: ext.value\n            };\n            headerExtensions.push(headerExtension);\n        }\n    }\n    const rtpCapabilities = {\n        codecs: Array.from(codecsMap.values()),\n        headerExtensions: headerExtensions\n    };\n    return rtpCapabilities;\n}\nexports.extractRtpCapabilities = extractRtpCapabilities;\nfunction extractDtlsParameters({ sdpObject }) {\n    const mediaObject = (sdpObject.media || [])\n        .find((m) => (m.iceUfrag && m.port !== 0));\n    if (!mediaObject)\n        throw new Error('no active media section found');\n    const fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;\n    let role;\n    switch (mediaObject.setup) {\n        case 'active':\n            role = 'client';\n            break;\n        case 'passive':\n            role = 'server';\n            break;\n        case 'actpass':\n            role = 'auto';\n            break;\n    }\n    const dtlsParameters = {\n        role,\n        fingerprints: [\n            {\n                algorithm: fingerprint.type,\n                value: fingerprint.hash\n            }\n        ]\n    };\n    return dtlsParameters;\n}\nexports.extractDtlsParameters = extractDtlsParameters;\nfunction getCname({ offerMediaObject }) {\n    const ssrcCnameLine = (offerMediaObject.ssrcs || [])\n        .find((line) => line.attribute === 'cname');\n    if (!ssrcCnameLine)\n        return '';\n    return ssrcCnameLine.value;\n}\nexports.getCname = getCname;\n/**\n * Apply codec parameters in the given SDP m= section answer based on the\n * given RTP parameters of an offer.\n */\nfunction applyCodecParameters({ offerRtpParameters, answerMediaObject }) {\n    for (const codec of offerRtpParameters.codecs) {\n        const mimeType = codec.mimeType.toLowerCase();\n        // Avoid parsing codec parameters for unhandled codecs.\n        if (mimeType !== 'audio/opus')\n            continue;\n        const rtp = (answerMediaObject.rtp || [])\n            .find((r) => r.payload === codec.payloadType);\n        if (!rtp)\n            continue;\n        // Just in case.\n        answerMediaObject.fmtp = answerMediaObject.fmtp || [];\n        let fmtp = answerMediaObject.fmtp\n            .find((f) => f.payload === codec.payloadType);\n        if (!fmtp) {\n            fmtp = { payload: codec.payloadType, config: '' };\n            answerMediaObject.fmtp.push(fmtp);\n        }\n        const parameters = sdpTransform.parseParams(fmtp.config);\n        switch (mimeType) {\n            case 'audio/opus':\n                {\n                    const spropStereo = codec.parameters['sprop-stereo'];\n                    if (spropStereo !== undefined)\n                        parameters.stereo = spropStereo ? 1 : 0;\n                    break;\n                }\n        }\n        // Write the codec fmtp.config back.\n        fmtp.config = '';\n        for (const key of Object.keys(parameters)) {\n            if (fmtp.config)\n                fmtp.config += ';';\n            fmtp.config += `${key}=${parameters[key]}`;\n        }\n    }\n}\nexports.applyCodecParameters = applyCodecParameters;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}