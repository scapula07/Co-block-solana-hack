{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoAccount = void 0;\nconst _1 = require(\".\");\nconst lib_1 = require(\"./lib\");\nconst RegistryItem_1 = require(\"./RegistryItem\");\nconst RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n  Keys[Keys[\"masterFingerprint\"] = 1] = \"masterFingerprint\";\n  Keys[Keys[\"outputDescriptors\"] = 2] = \"outputDescriptors\";\n})(Keys || (Keys = {}));\nclass CryptoAccount extends RegistryItem_1.RegistryItem {\n  constructor(masterFingerprint, outputDescriptors) {\n    super();\n    this.masterFingerprint = masterFingerprint;\n    this.outputDescriptors = outputDescriptors;\n    this.getRegistryType = () => {\n      return RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT;\n    };\n    this.getMasterFingerprint = () => this.masterFingerprint;\n    this.getOutputDescriptors = () => this.outputDescriptors;\n    this.toDataItem = () => {\n      const map = {};\n      if (this.masterFingerprint) {\n        map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);\n      }\n      if (this.outputDescriptors) {\n        map[Keys.outputDescriptors] = this.outputDescriptors.map(item => item.toDataItem());\n      }\n      return new lib_1.DataItem(map);\n    };\n  }\n}\nexports.CryptoAccount = CryptoAccount;\nCryptoAccount.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const masterFingerprint = Buffer.alloc(4);\n  const _masterFingerprint = map[Keys.masterFingerprint];\n  if (_masterFingerprint) {\n    masterFingerprint.writeUInt32BE(_masterFingerprint, 0);\n  }\n  const outputDescriptors = map[Keys.outputDescriptors];\n  const cryptoOutputs = outputDescriptors.map(item => _1.CryptoOutput.fromDataItem(item));\n  return new CryptoAccount(masterFingerprint, cryptoOutputs);\n};\nCryptoAccount.fromCBOR = _cborPayload => {\n  const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoAccount.fromDataItem(dataItem);\n};","map":{"version":3,"mappings":";;;;;;AAAA;AACA;AACA;AACA;AAGA,IAAKA,IAGJ;AAHD,WAAKA,IAAI;EACPA,yDAAqB;EACrBA,yDAAiB;AACnB,CAAC,EAHIA,IAAI,KAAJA,IAAI;AAKT,MAAaC,aAAc,SAAQC,2BAAY;EAK7CC,YACUC,iBAAyB,EACzBC,iBAAiC;IAEzC,KAAK,EAAE;IAHC,sBAAiB,GAAjBD,iBAAiB;IACjB,sBAAiB,GAAjBC,iBAAiB;IAN3B,oBAAe,GAAG,MAAK;MACrB,OAAOC,4BAAa,CAACC,cAAc;IACrC,CAAC;IASM,yBAAoB,GAAG,MAAM,IAAI,CAACH,iBAAiB;IACnD,yBAAoB,GAAG,MAAM,IAAI,CAACC,iBAAiB;IAEnD,eAAU,GAAG,MAAK;MACvB,MAAMG,GAAG,GAAgB,EAAE;MAC3B,IAAI,IAAI,CAACJ,iBAAiB,EAAE;QAC1BI,GAAG,CAACR,IAAI,CAACI,iBAAiB,CAAC,GAAG,IAAI,CAACA,iBAAiB,CAACK,YAAY,CAAC,CAAC,CAAC;;MAEtE,IAAI,IAAI,CAACJ,iBAAiB,EAAE;QAC1BG,GAAG,CAACR,IAAI,CAACK,iBAAiB,CAAC,GAAG,IAAI,CAACA,iBAAiB,CAACG,GAAG,CAAEE,IAAI,IAC5DA,IAAI,CAACC,UAAU,EAAE,CAClB;;MAEH,OAAO,IAAIC,cAAQ,CAACJ,GAAG,CAAC;IAC1B,CAAC;EAhBD;;AAVFK;AA4BgBZ,0BAAY,GAAIa,QAAkB,IAAI;EAClD,MAAMN,GAAG,GAAGM,QAAQ,CAACC,OAAO,EAAE;EAC9B,MAAMX,iBAAiB,GAAGY,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;EACzC,MAAMC,kBAAkB,GAAGV,GAAG,CAACR,IAAI,CAACI,iBAAiB,CAAC;EACtD,IAAIc,kBAAkB,EAAE;IACtBd,iBAAiB,CAACe,aAAa,CAACD,kBAAkB,EAAE,CAAC,CAAC;;EAExD,MAAMb,iBAAiB,GAAGG,GAAG,CAACR,IAAI,CAACK,iBAAiB,CAAe;EACnE,MAAMe,aAAa,GAAGf,iBAAiB,CAACG,GAAG,CAAEE,IAAI,IAC/CW,eAAY,CAACC,YAAY,CAACZ,IAAI,CAAC,CAChC;EACD,OAAO,IAAIT,aAAa,CAACG,iBAAiB,EAAEgB,aAAa,CAAC;AAC5D,CAAC;AAEanB,sBAAQ,GAAIsB,YAAoB,IAAI;EAChD,MAAMT,QAAQ,GAAG,0BAAgB,EAACS,YAAY,CAAC;EAC/C,OAAOtB,aAAa,CAACqB,YAAY,CAACR,QAAQ,CAAC;AAC7C,CAAC","names":["Keys","CryptoAccount","RegistryItem_1","constructor","masterFingerprint","outputDescriptors","RegistryType_1","CRYPTO_ACCOUNT","map","readUInt32BE","item","toDataItem","lib_1","exports","dataItem","getData","Buffer","alloc","_masterFingerprint","writeUInt32BE","cryptoOutputs","_1","fromDataItem","_cborPayload"],"sources":["/Users/user/Desktop/solana-hack-1/solana-payroll/node_modules/@keystonehq/bc-ur-registry/src/CryptoAccount.ts"],"sourcesContent":["import { CryptoOutput } from '.';\nimport { decodeToDataItem, DataItem } from './lib';\nimport { RegistryItem } from './RegistryItem';\nimport { RegistryTypes } from './RegistryType';\nimport { DataItemMap } from './types';\n\nenum Keys {\n  masterFingerprint = 1,\n  outputDescriptors,\n}\n\nexport class CryptoAccount extends RegistryItem {\n  getRegistryType = () => {\n    return RegistryTypes.CRYPTO_ACCOUNT;\n  };\n\n  constructor(\n    private masterFingerprint: Buffer,\n    private outputDescriptors: CryptoOutput[],\n  ) {\n    super();\n  }\n\n  public getMasterFingerprint = () => this.masterFingerprint;\n  public getOutputDescriptors = () => this.outputDescriptors;\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    if (this.masterFingerprint) {\n      map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);\n    }\n    if (this.outputDescriptors) {\n      map[Keys.outputDescriptors] = this.outputDescriptors.map((item) =>\n        item.toDataItem(),\n      );\n    }\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const masterFingerprint = Buffer.alloc(4);\n    const _masterFingerprint = map[Keys.masterFingerprint];\n    if (_masterFingerprint) {\n      masterFingerprint.writeUInt32BE(_masterFingerprint, 0);\n    }\n    const outputDescriptors = map[Keys.outputDescriptors] as DataItem[];\n    const cryptoOutputs = outputDescriptors.map((item) =>\n      CryptoOutput.fromDataItem(item),\n    );\n    return new CryptoAccount(masterFingerprint, cryptoOutputs);\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoAccount.fromDataItem(dataItem);\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}