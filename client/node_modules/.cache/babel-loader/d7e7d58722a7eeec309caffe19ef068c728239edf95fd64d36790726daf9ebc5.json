{"ast":null,"code":"import { createDefaultAddressSelector, createDefaultAuthorizationResultCache, createDefaultWalletNotFoundHandler, SolanaMobileWalletAdapter, SolanaMobileWalletAdapterWalletName } from '@solana-mobile/wallet-adapter-mobile';\nimport { useStandardWalletAdapters } from '@solana/wallet-standard-wallet-adapter-react';\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport getEnvironment, { Environment } from './getEnvironment.js';\nimport getInferredClusterFromEndpoint from './getInferredClusterFromEndpoint.js';\nimport { useConnection } from './useConnection.js';\nimport { useLocalStorage } from './useLocalStorage.js';\nimport { WalletProviderBase } from './WalletProviderBase.js';\nlet _userAgent;\nfunction getUserAgent() {\n  if (_userAgent === undefined) {\n    _userAgent = globalThis.navigator?.userAgent ?? null;\n  }\n  return _userAgent;\n}\nfunction getIsMobile(adapters) {\n  const userAgentString = getUserAgent();\n  return getEnvironment({\n    adapters,\n    userAgentString\n  }) === Environment.MOBILE_WEB;\n}\nfunction getUriForAppIdentity() {\n  const location = globalThis.location;\n  if (location == null) {\n    return;\n  }\n  return `${location.protocol}//${location.host}`;\n}\nexport function WalletProvider(_ref) {\n  let {\n    children,\n    wallets: adapters,\n    autoConnect,\n    localStorageKey = 'walletName',\n    onError\n  } = _ref;\n  const {\n    connection\n  } = useConnection();\n  const adaptersWithStandardAdapters = useStandardWalletAdapters(adapters);\n  const mobileWalletAdapter = useMemo(() => {\n    if (!getIsMobile(adaptersWithStandardAdapters)) {\n      return null;\n    }\n    const existingMobileWalletAdapter = adaptersWithStandardAdapters.find(adapter => adapter.name === SolanaMobileWalletAdapterWalletName);\n    if (existingMobileWalletAdapter) {\n      return existingMobileWalletAdapter;\n    }\n    return new SolanaMobileWalletAdapter({\n      addressSelector: createDefaultAddressSelector(),\n      appIdentity: {\n        uri: getUriForAppIdentity()\n      },\n      authorizationResultCache: createDefaultAuthorizationResultCache(),\n      cluster: getInferredClusterFromEndpoint(connection?.rpcEndpoint),\n      onWalletNotFound: createDefaultWalletNotFoundHandler()\n    });\n  }, [adaptersWithStandardAdapters, connection?.rpcEndpoint]);\n  const adaptersWithMobileWalletAdapter = useMemo(() => {\n    if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n      return adaptersWithStandardAdapters;\n    }\n    return [mobileWalletAdapter, ...adaptersWithStandardAdapters];\n  }, [adaptersWithStandardAdapters, mobileWalletAdapter]);\n  const [walletName, setWalletName] = useLocalStorage(localStorageKey, getIsMobile(adaptersWithStandardAdapters) ? SolanaMobileWalletAdapterWalletName : null);\n  const adapter = useMemo(() => adaptersWithMobileWalletAdapter.find(a => a.name === walletName) ?? null, [adaptersWithMobileWalletAdapter, walletName]);\n  const changeWallet = useCallback(nextWalletName => {\n    if (walletName === nextWalletName) {\n      return;\n    }\n    if (adapter &&\n    // Selecting a wallet other than the mobile wallet adapter is not\n    // sufficient reason to call `disconnect` on the mobile wallet adapter.\n    // Calling `disconnect` on the mobile wallet adapter causes the entire\n    // authorization store to be wiped.\n    adapter.name !== SolanaMobileWalletAdapterWalletName) {\n      adapter.disconnect();\n    }\n    setWalletName(nextWalletName);\n  }, [adapter, setWalletName, walletName]);\n  useEffect(() => {\n    if (adapter == null) {\n      return;\n    }\n    function handleDisconnect() {\n      if (isUnloadingRef.current) {\n        return;\n      }\n      if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n        // Leave the adapter selected in the event of a disconnection.\n        return;\n      }\n      setWalletName(null);\n    }\n    adapter.on('disconnect', handleDisconnect);\n    return () => {\n      adapter.off('disconnect', handleDisconnect);\n    };\n  }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);\n  const hasUserSelectedAWallet = useRef(false);\n  const handleAutoConnectRequest = useMemo(() => {\n    if (autoConnect !== true || !adapter) {\n      return;\n    }\n    return () => hasUserSelectedAWallet.current ? adapter.connect() : adapter.autoConnect();\n  }, [adapter, autoConnect]);\n  const isUnloadingRef = useRef(false);\n  useEffect(() => {\n    if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n      isUnloadingRef.current = false;\n      return;\n    }\n    function handleBeforeUnload() {\n      isUnloadingRef.current = true;\n    }\n    /**\n     * Some wallets fire disconnection events when the window unloads. Since there's no way to\n     * distinguish between a disconnection event received because a user initiated it, and one\n     * that was received because they've closed the window, we have to track window unload\n     * events themselves. Downstream components use this information to decide whether to act\n     * upon or drop wallet events and errors.\n     */\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    return () => {\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n    };\n  }, [adaptersWithStandardAdapters, walletName]);\n  const handleConnectError = useCallback(() => {\n    if (adapter && adapter.name !== SolanaMobileWalletAdapterWalletName) {\n      // If any error happens while connecting, unset the adapter.\n      changeWallet(null);\n    }\n  }, [adapter, changeWallet]);\n  const selectWallet = useCallback(walletName => {\n    hasUserSelectedAWallet.current = true;\n    changeWallet(walletName);\n  }, [changeWallet]);\n  return React.createElement(WalletProviderBase, {\n    wallets: adaptersWithMobileWalletAdapter,\n    adapter: adapter,\n    isUnloadingRef: isUnloadingRef,\n    onAutoConnectRequest: handleAutoConnectRequest,\n    onConnectError: handleConnectError,\n    onError: onError,\n    onSelectWallet: selectWallet\n  }, children);\n}","map":{"version":3,"mappings":"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","names":["createDefaultAddressSelector","createDefaultAuthorizationResultCache","createDefaultWalletNotFoundHandler","SolanaMobileWalletAdapter","SolanaMobileWalletAdapterWalletName","useStandardWalletAdapters","React","useCallback","useEffect","useMemo","useRef","getEnvironment","Environment","getInferredClusterFromEndpoint","useConnection","useLocalStorage","WalletProviderBase","_userAgent","getUserAgent","undefined","globalThis","navigator","userAgent","getIsMobile","adapters","userAgentString","MOBILE_WEB","getUriForAppIdentity","location","protocol","host","WalletProvider","children","wallets","autoConnect","localStorageKey","onError","connection","adaptersWithStandardAdapters","mobileWalletAdapter","existingMobileWalletAdapter","find","adapter","name","addressSelector","appIdentity","uri","authorizationResultCache","cluster","rpcEndpoint","onWalletNotFound","adaptersWithMobileWalletAdapter","indexOf","walletName","setWalletName","a","changeWallet","nextWalletName","disconnect","handleDisconnect","isUnloadingRef","current","on","off","hasUserSelectedAWallet","handleAutoConnectRequest","connect","handleBeforeUnload","window","addEventListener","removeEventListener","handleConnectError","selectWallet","onAutoConnectRequest","onConnectError","onSelectWallet"],"sources":["/Users/user/Desktop/solana-hack-1/client/node_modules/@solana/wallet-adapter-react/src/WalletProvider.tsx"],"sourcesContent":["import {\n    createDefaultAddressSelector,\n    createDefaultAuthorizationResultCache,\n    createDefaultWalletNotFoundHandler,\n    SolanaMobileWalletAdapter,\n    SolanaMobileWalletAdapterWalletName,\n} from '@solana-mobile/wallet-adapter-mobile';\nimport { type Adapter, type WalletError, type WalletName } from '@solana/wallet-adapter-base';\nimport { useStandardWalletAdapters } from '@solana/wallet-standard-wallet-adapter-react';\nimport React, { type ReactNode, useCallback, useEffect, useMemo, useRef } from 'react';\nimport getEnvironment, { Environment } from './getEnvironment.js';\nimport getInferredClusterFromEndpoint from './getInferredClusterFromEndpoint.js';\nimport { useConnection } from './useConnection.js';\nimport { useLocalStorage } from './useLocalStorage.js';\nimport { WalletProviderBase } from './WalletProviderBase.js';\n\nexport interface WalletProviderProps {\n    children: ReactNode;\n    wallets: Adapter[];\n    autoConnect?: boolean;\n    localStorageKey?: string;\n    onError?: (error: WalletError, adapter?: Adapter) => void;\n}\n\nlet _userAgent: string | null;\nfunction getUserAgent() {\n    if (_userAgent === undefined) {\n        _userAgent = globalThis.navigator?.userAgent ?? null;\n    }\n    return _userAgent;\n}\n\nfunction getIsMobile(adapters: Adapter[]) {\n    const userAgentString = getUserAgent();\n    return getEnvironment({ adapters, userAgentString }) === Environment.MOBILE_WEB;\n}\n\nfunction getUriForAppIdentity() {\n    const location = globalThis.location;\n    if (location == null) {\n        return;\n    }\n    return `${location.protocol}//${location.host}`;\n}\n\nexport function WalletProvider({\n    children,\n    wallets: adapters,\n    autoConnect,\n    localStorageKey = 'walletName',\n    onError,\n}: WalletProviderProps) {\n    const { connection } = useConnection();\n    const adaptersWithStandardAdapters = useStandardWalletAdapters(adapters);\n    const mobileWalletAdapter = useMemo(() => {\n        if (!getIsMobile(adaptersWithStandardAdapters)) {\n            return null;\n        }\n        const existingMobileWalletAdapter = adaptersWithStandardAdapters.find(\n            (adapter) => adapter.name === SolanaMobileWalletAdapterWalletName\n        );\n        if (existingMobileWalletAdapter) {\n            return existingMobileWalletAdapter;\n        }\n        return new SolanaMobileWalletAdapter({\n            addressSelector: createDefaultAddressSelector(),\n            appIdentity: {\n                uri: getUriForAppIdentity(),\n            },\n            authorizationResultCache: createDefaultAuthorizationResultCache(),\n            cluster: getInferredClusterFromEndpoint(connection?.rpcEndpoint),\n            onWalletNotFound: createDefaultWalletNotFoundHandler(),\n        });\n    }, [adaptersWithStandardAdapters, connection?.rpcEndpoint]);\n    const adaptersWithMobileWalletAdapter = useMemo(() => {\n        if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n            return adaptersWithStandardAdapters;\n        }\n        return [mobileWalletAdapter, ...adaptersWithStandardAdapters];\n    }, [adaptersWithStandardAdapters, mobileWalletAdapter]);\n    const [walletName, setWalletName] = useLocalStorage<WalletName | null>(\n        localStorageKey,\n        getIsMobile(adaptersWithStandardAdapters) ? SolanaMobileWalletAdapterWalletName : null\n    );\n    const adapter = useMemo(\n        () => adaptersWithMobileWalletAdapter.find((a) => a.name === walletName) ?? null,\n        [adaptersWithMobileWalletAdapter, walletName]\n    );\n    const changeWallet = useCallback(\n        (nextWalletName: WalletName<string> | null) => {\n            if (walletName === nextWalletName) {\n                return;\n            }\n            if (\n                adapter &&\n                // Selecting a wallet other than the mobile wallet adapter is not\n                // sufficient reason to call `disconnect` on the mobile wallet adapter.\n                // Calling `disconnect` on the mobile wallet adapter causes the entire\n                // authorization store to be wiped.\n                adapter.name !== SolanaMobileWalletAdapterWalletName\n            ) {\n                adapter.disconnect();\n            }\n            setWalletName(nextWalletName);\n        },\n        [adapter, setWalletName, walletName]\n    );\n    useEffect(() => {\n        if (adapter == null) {\n            return;\n        }\n        function handleDisconnect() {\n            if (isUnloadingRef.current) {\n                return;\n            }\n            if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n                // Leave the adapter selected in the event of a disconnection.\n                return;\n            }\n            setWalletName(null);\n        }\n        adapter.on('disconnect', handleDisconnect);\n        return () => {\n            adapter.off('disconnect', handleDisconnect);\n        };\n    }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);\n    const hasUserSelectedAWallet = useRef(false);\n    const handleAutoConnectRequest = useMemo(() => {\n        if (autoConnect !== true || !adapter) {\n            return;\n        }\n\n        return () => (hasUserSelectedAWallet.current ? adapter.connect() : adapter.autoConnect());\n    }, [adapter, autoConnect]);\n    const isUnloadingRef = useRef(false);\n    useEffect(() => {\n        if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n            isUnloadingRef.current = false;\n            return;\n        }\n        function handleBeforeUnload() {\n            isUnloadingRef.current = true;\n        }\n        /**\n         * Some wallets fire disconnection events when the window unloads. Since there's no way to\n         * distinguish between a disconnection event received because a user initiated it, and one\n         * that was received because they've closed the window, we have to track window unload\n         * events themselves. Downstream components use this information to decide whether to act\n         * upon or drop wallet events and errors.\n         */\n        window.addEventListener('beforeunload', handleBeforeUnload);\n        return () => {\n            window.removeEventListener('beforeunload', handleBeforeUnload);\n        };\n    }, [adaptersWithStandardAdapters, walletName]);\n    const handleConnectError = useCallback(() => {\n        if (adapter && adapter.name !== SolanaMobileWalletAdapterWalletName) {\n            // If any error happens while connecting, unset the adapter.\n            changeWallet(null);\n        }\n    }, [adapter, changeWallet]);\n    const selectWallet = useCallback(\n        (walletName: WalletName | null) => {\n            hasUserSelectedAWallet.current = true;\n            changeWallet(walletName);\n        },\n        [changeWallet]\n    );\n    return (\n        <WalletProviderBase\n            wallets={adaptersWithMobileWalletAdapter}\n            adapter={adapter}\n            isUnloadingRef={isUnloadingRef}\n            onAutoConnectRequest={handleAutoConnectRequest}\n            onConnectError={handleConnectError}\n            onError={onError}\n            onSelectWallet={selectWallet}\n        >\n            {children}\n        </WalletProviderBase>\n    );\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}