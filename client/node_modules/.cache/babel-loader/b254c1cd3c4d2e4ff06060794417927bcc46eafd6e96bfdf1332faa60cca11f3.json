{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoHDKey = void 0;\nconst bs58check_1 = require(\"bs58check\");\nconst CryptoCoinInfo_1 = require(\"./CryptoCoinInfo\");\nconst CryptoKeypath_1 = require(\"./CryptoKeypath\");\nconst lib_1 = require(\"./lib\");\nconst RegistryItem_1 = require(\"./RegistryItem\");\nconst RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n  Keys[Keys[\"is_master\"] = 1] = \"is_master\";\n  Keys[Keys[\"is_private\"] = 2] = \"is_private\";\n  Keys[Keys[\"key_data\"] = 3] = \"key_data\";\n  Keys[Keys[\"chain_code\"] = 4] = \"chain_code\";\n  Keys[Keys[\"use_info\"] = 5] = \"use_info\";\n  Keys[Keys[\"origin\"] = 6] = \"origin\";\n  Keys[Keys[\"children\"] = 7] = \"children\";\n  Keys[Keys[\"parent_fingerprint\"] = 8] = \"parent_fingerprint\";\n  Keys[Keys[\"name\"] = 9] = \"name\";\n  Keys[Keys[\"note\"] = 10] = \"note\";\n})(Keys || (Keys = {}));\nclass CryptoHDKey extends RegistryItem_1.RegistryItem {\n  constructor(args) {\n    super();\n    this.isECKey = () => {\n      return false;\n    };\n    this.getKey = () => this.key;\n    this.getChainCode = () => this.chainCode;\n    this.isMaster = () => this.master;\n    this.isPrivateKey = () => !!this.privateKey;\n    this.getUseInfo = () => this.useInfo;\n    this.getOrigin = () => this.origin;\n    this.getChildren = () => this.children;\n    this.getParentFingerprint = () => this.parentFingerprint;\n    this.getName = () => this.name;\n    this.getNote = () => this.note;\n    this.getBip32Key = () => {\n      var _a, _b, _c;\n      let version;\n      let depth;\n      let index = 0;\n      let parentFingerprint = Buffer.alloc(4).fill(0);\n      if (this.isMaster()) {\n        version = Buffer.from('0488ADE4', 'hex');\n        depth = 0;\n        index = 0;\n      } else {\n        depth = ((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getComponents().length) || ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getDepth());\n        const paths = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getComponents();\n        const lastPath = paths[paths.length - 1];\n        if (lastPath) {\n          index = lastPath.isHardened() ? lastPath.getIndex() + 0x80000000 : lastPath.getIndex();\n          if (this.getParentFingerprint()) {\n            parentFingerprint = this.getParentFingerprint();\n          }\n        }\n        if (this.isPrivateKey()) {\n          version = Buffer.from('0488ADE4', 'hex');\n        } else {\n          version = Buffer.from('0488B21E', 'hex');\n        }\n      }\n      const depthBuffer = Buffer.alloc(1);\n      depthBuffer.writeUInt8(depth, 0);\n      const indexBuffer = Buffer.alloc(4);\n      indexBuffer.writeUInt32BE(index, 0);\n      const chainCode = this.getChainCode();\n      const key = this.getKey();\n      return (0, bs58check_1.encode)(Buffer.concat([version, depthBuffer, parentFingerprint, indexBuffer, chainCode, key]));\n    };\n    this.getRegistryType = () => {\n      return RegistryType_1.RegistryTypes.CRYPTO_HDKEY;\n    };\n    this.getOutputDescriptorContent = () => {\n      var _a, _b, _c, _d, _e, _f, _g;\n      let result = '';\n      if (this.getOrigin()) {\n        if (((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getSourceFingerprint()) && ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getPath())) {\n          result += `${(_d = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getSourceFingerprint()) === null || _d === void 0 ? void 0 : _d.toString('hex')}/${(_e = this.getOrigin()) === null || _e === void 0 ? void 0 : _e.getPath()}`;\n        }\n      }\n      result += this.getBip32Key();\n      if (this.getChildren()) {\n        if ((_f = this.getChildren()) === null || _f === void 0 ? void 0 : _f.getPath()) {\n          result += `/${(_g = this.getChildren()) === null || _g === void 0 ? void 0 : _g.getPath()}`;\n        }\n      }\n      return result;\n    };\n    this.setupMasterKey = args => {\n      this.master = true;\n      this.key = args.key;\n      this.chainCode = args.chainCode;\n    };\n    this.setupDeriveKey = args => {\n      this.master = false;\n      this.privateKey = args.isPrivateKey;\n      this.key = args.key;\n      this.chainCode = args.chainCode;\n      this.useInfo = args.useInfo;\n      this.origin = args.origin;\n      this.children = args.children;\n      this.parentFingerprint = args.parentFingerprint;\n      this.name = args.name;\n      this.note = args.note;\n    };\n    this.toDataItem = () => {\n      const map = {};\n      if (this.master) {\n        map[Keys.is_master] = true;\n        map[Keys.key_data] = this.key;\n        map[Keys.chain_code] = this.chainCode;\n      } else {\n        if (this.privateKey !== undefined) {\n          map[Keys.is_private] = this.privateKey;\n        }\n        map[Keys.key_data] = this.key;\n        if (this.chainCode) {\n          map[Keys.chain_code] = this.chainCode;\n        }\n        if (this.useInfo) {\n          const useInfo = this.useInfo.toDataItem();\n          useInfo.setTag(this.useInfo.getRegistryType().getTag());\n          map[Keys.use_info] = useInfo;\n        }\n        if (this.origin) {\n          const origin = this.origin.toDataItem();\n          origin.setTag(this.origin.getRegistryType().getTag());\n          map[Keys.origin] = origin;\n        }\n        if (this.children) {\n          const children = this.children.toDataItem();\n          children.setTag(this.children.getRegistryType().getTag());\n          map[Keys.children] = children;\n        }\n        if (this.parentFingerprint) {\n          map[Keys.parent_fingerprint] = this.parentFingerprint.readUInt32BE(0);\n        }\n        if (this.name !== undefined) {\n          map[Keys.name] = this.name;\n        }\n        if (this.note !== undefined) {\n          map[Keys.note] = this.note;\n        }\n      }\n      return new lib_1.DataItem(map);\n    };\n    if (args.isMaster) {\n      this.setupMasterKey(args);\n    } else {\n      this.setupDeriveKey(args);\n    }\n  }\n}\nexports.CryptoHDKey = CryptoHDKey;\nCryptoHDKey.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const isMaster = !!map[Keys.is_master];\n  const isPrivateKey = map[Keys.is_private];\n  const key = map[Keys.key_data];\n  const chainCode = map[Keys.chain_code];\n  const useInfo = map[Keys.use_info] ? CryptoCoinInfo_1.CryptoCoinInfo.fromDataItem(map[Keys.use_info]) : undefined;\n  const origin = map[Keys.origin] ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.origin]) : undefined;\n  const children = map[Keys.children] ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.children]) : undefined;\n  const _parentFingerprint = map[Keys.parent_fingerprint];\n  let parentFingerprint = undefined;\n  if (_parentFingerprint) {\n    parentFingerprint = Buffer.alloc(4);\n    parentFingerprint.writeUInt32BE(_parentFingerprint, 0);\n  }\n  const name = map[Keys.name];\n  const note = map[Keys.note];\n  return new CryptoHDKey({\n    isMaster,\n    isPrivateKey,\n    key,\n    chainCode,\n    useInfo,\n    origin,\n    children,\n    parentFingerprint,\n    name,\n    note\n  });\n};\nCryptoHDKey.fromCBOR = _cborPayload => {\n  const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoHDKey.fromDataItem(dataItem);\n};","map":{"version":3,"mappings":"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","names":["Keys","CryptoHDKey","RegistryItem_1","constructor","args","key","chainCode","master","privateKey","useInfo","origin","children","parentFingerprint","name","note","version","depth","index","Buffer","alloc","fill","isMaster","from","getOrigin","getComponents","length","getDepth","paths","lastPath","isHardened","getIndex","getParentFingerprint","isPrivateKey","depthBuffer","writeUInt8","indexBuffer","writeUInt32BE","getChainCode","getKey","concat","RegistryType_1","CRYPTO_HDKEY","result","getSourceFingerprint","getPath","toString","getBip32Key","getChildren","map","is_master","key_data","chain_code","undefined","is_private","toDataItem","setTag","getRegistryType","getTag","use_info","parent_fingerprint","readUInt32BE","lib_1","setupMasterKey","setupDeriveKey","exports","dataItem","getData","CryptoCoinInfo_1","fromDataItem","CryptoKeypath_1","_parentFingerprint","_cborPayload"],"sources":["/Users/user/Desktop/solana-hack-1/client/node_modules/@keystonehq/bc-ur-registry/src/CryptoHDKey.ts"],"sourcesContent":["import { encode } from 'bs58check';\nimport { CryptoCoinInfo } from './CryptoCoinInfo';\nimport { CryptoKeypath } from './CryptoKeypath';\nimport { decodeToDataItem, DataItem } from './lib';\nimport { RegistryItem } from './RegistryItem';\nimport { RegistryTypes } from './RegistryType';\nimport { DataItemMap, ICryptoKey } from './types';\nimport { PathComponent } from './PathComponent';\n\nenum Keys {\n  is_master = 1,\n  is_private,\n  key_data,\n  chain_code,\n  use_info,\n  origin,\n  children,\n  parent_fingerprint,\n  name,\n  note,\n}\n\ntype MasterKeyProps = {\n  isMaster: true;\n  key: Buffer;\n  chainCode: Buffer;\n};\n\ntype DeriveKeyProps = {\n  isMaster: false;\n  isPrivateKey?: boolean;\n  key: Buffer;\n  chainCode?: Buffer;\n  useInfo?: CryptoCoinInfo;\n  origin?: CryptoKeypath;\n  children?: CryptoKeypath;\n  parentFingerprint?: Buffer;\n  name?: string;\n  note?: string;\n};\n\nexport class CryptoHDKey extends RegistryItem implements ICryptoKey {\n  private master?: boolean;\n  private privateKey?: boolean;\n  private key?: Buffer;\n  private chainCode?: Buffer;\n  private useInfo?: CryptoCoinInfo;\n  private origin?: CryptoKeypath;\n  private children?: CryptoKeypath;\n  private parentFingerprint?: Buffer;\n  private name?: string;\n  private note?: string;\n\n  isECKey = () => {\n    return false;\n  };\n\n  public getKey = () => this.key;\n  public getChainCode = () => this.chainCode;\n  public isMaster = () => this.master;\n  public isPrivateKey = () => !!this.privateKey;\n  public getUseInfo = () => this.useInfo;\n  public getOrigin = () => this.origin;\n  public getChildren = () => this.children;\n  public getParentFingerprint = () => this.parentFingerprint;\n  public getName = () => this.name;\n  public getNote = () => this.note;\n  public getBip32Key = () => {\n    let version: Buffer;\n    let depth: number;\n    let index = 0;\n    let parentFingerprint: Buffer = Buffer.alloc(4).fill(0);\n    if (this.isMaster()) {\n      // version bytes defined on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format\n      version = Buffer.from('0488ADE4', 'hex');\n      depth = 0;\n      index = 0;\n    } else {\n      depth = this.getOrigin()?.getComponents().length || this.getOrigin()?.getDepth() as number;\n      const paths = this.getOrigin()?.getComponents() as PathComponent[];\n      const lastPath = paths[paths.length - 1];\n      if (lastPath) {\n        index = lastPath.isHardened() ? lastPath.getIndex()! + 0x80000000 : lastPath.getIndex()!;\n        if (this.getParentFingerprint()) {\n          parentFingerprint = this.getParentFingerprint() as Buffer;\n        }\n      }\n      if (this.isPrivateKey()) {\n        version = Buffer.from('0488ADE4', 'hex');\n      } else {\n        version = Buffer.from('0488B21E', 'hex');\n      }\n    }\n    const depthBuffer = Buffer.alloc(1);\n    depthBuffer.writeUInt8(depth, 0);\n    const indexBuffer = Buffer.alloc(4);\n    indexBuffer.writeUInt32BE(index, 0);\n    const chainCode = this.getChainCode();\n    const key = this.getKey();\n    return encode(Buffer.concat([version, depthBuffer, parentFingerprint, indexBuffer, chainCode as Buffer, key as Buffer]));\n  };\n\n  public getRegistryType = () => {\n    return RegistryTypes.CRYPTO_HDKEY;\n  };\n\n  public getOutputDescriptorContent = () => {\n    let result = '';\n    if (this.getOrigin()) {\n      if (this.getOrigin()?.getSourceFingerprint() && this.getOrigin()?.getPath()) {\n        result += `${this.getOrigin()?.getSourceFingerprint()?.toString('hex')}/${this.getOrigin()?.getPath()}`;\n      }\n    }\n    result += this.getBip32Key();\n    if (this.getChildren()) {\n      if (this.getChildren()?.getPath()) {\n        result += `/${this.getChildren()?.getPath()}`;\n      }\n    }\n    return result;\n  };\n\n  constructor(args: DeriveKeyProps | MasterKeyProps) {\n    super();\n    if (args.isMaster) {\n      this.setupMasterKey(args);\n    } else {\n      this.setupDeriveKey(args as DeriveKeyProps);\n    }\n  }\n\n  private setupMasterKey = (args: MasterKeyProps) => {\n    this.master = true;\n    this.key = args.key;\n    this.chainCode = args.chainCode;\n  };\n\n  private setupDeriveKey = (args: DeriveKeyProps) => {\n    this.master = false;\n    this.privateKey = args.isPrivateKey;\n    this.key = args.key;\n    this.chainCode = args.chainCode;\n    this.useInfo = args.useInfo;\n    this.origin = args.origin;\n    this.children = args.children;\n    this.parentFingerprint = args.parentFingerprint;\n    this.name = args.name;\n    this.note = args.note;\n  };\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    if (this.master) {\n      map[Keys.is_master] = true;\n      map[Keys.key_data] = this.key;\n      map[Keys.chain_code] = this.chainCode;\n    } else {\n      if (this.privateKey !== undefined) {\n        map[Keys.is_private] = this.privateKey;\n      }\n      map[Keys.key_data] = this.key;\n      if (this.chainCode) {\n        map[Keys.chain_code] = this.chainCode;\n      }\n      if (this.useInfo) {\n        const useInfo = this.useInfo.toDataItem();\n        useInfo.setTag(this.useInfo.getRegistryType().getTag());\n        map[Keys.use_info] = useInfo;\n      }\n      if (this.origin) {\n        const origin = this.origin.toDataItem();\n        origin.setTag(this.origin.getRegistryType().getTag());\n        map[Keys.origin] = origin;\n      }\n      if (this.children) {\n        const children = this.children.toDataItem();\n        children.setTag(this.children.getRegistryType().getTag());\n        map[Keys.children] = children;\n      }\n      if (this.parentFingerprint) {\n        map[Keys.parent_fingerprint] = this.parentFingerprint.readUInt32BE(0);\n      }\n      if (this.name !== undefined) {\n        map[Keys.name] = this.name;\n      }\n      if (this.note !== undefined) {\n        map[Keys.note] = this.note;\n      }\n    }\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const isMaster = !!map[Keys.is_master];\n    const isPrivateKey = map[Keys.is_private];\n    const key = map[Keys.key_data];\n    const chainCode = map[Keys.chain_code];\n    const useInfo = map[Keys.use_info]\n      ? CryptoCoinInfo.fromDataItem(map[Keys.use_info])\n      : undefined;\n    const origin = map[Keys.origin]\n      ? CryptoKeypath.fromDataItem(map[Keys.origin])\n      : undefined;\n    const children = map[Keys.children]\n      ? CryptoKeypath.fromDataItem(map[Keys.children])\n      : undefined;\n    const _parentFingerprint = map[Keys.parent_fingerprint];\n    let parentFingerprint: Buffer | undefined = undefined;\n    if (_parentFingerprint) {\n      parentFingerprint = Buffer.alloc(4);\n      parentFingerprint.writeUInt32BE(_parentFingerprint, 0);\n    }\n    const name = map[Keys.name];\n    const note = map[Keys.note];\n\n    return new CryptoHDKey({\n      isMaster,\n      isPrivateKey,\n      key,\n      chainCode,\n      useInfo,\n      origin,\n      children,\n      parentFingerprint,\n      name,\n      note,\n    });\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoHDKey.fromDataItem(dataItem);\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}