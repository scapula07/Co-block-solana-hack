{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar wipe_1 = require(\"@stablelib/wipe\");\nvar NodeRandomSource = /** @class */function () {\n  function NodeRandomSource() {\n    this.isAvailable = false;\n    this.isInstantiated = false;\n    if (typeof require !== \"undefined\") {\n      var nodeCrypto = require(\"crypto\");\n      if (nodeCrypto && nodeCrypto.randomBytes) {\n        this._crypto = nodeCrypto;\n        this.isAvailable = true;\n        this.isInstantiated = true;\n      }\n    }\n  }\n  NodeRandomSource.prototype.randomBytes = function (length) {\n    if (!this.isAvailable || !this._crypto) {\n      throw new Error(\"Node.js random byte generator is not available.\");\n    }\n    // Get random bytes (result is Buffer).\n    var buffer = this._crypto.randomBytes(length);\n    // Make sure we got the length that we requested.\n    if (buffer.length !== length) {\n      throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n    }\n    // Allocate output array.\n    var out = new Uint8Array(length);\n    // Copy bytes from buffer to output.\n    for (var i = 0; i < out.length; i++) {\n      out[i] = buffer[i];\n    }\n    // Cleanup.\n    wipe_1.wipe(buffer);\n    return out;\n  };\n  return NodeRandomSource;\n}();\nexports.NodeRandomSource = NodeRandomSource;","map":{"version":3,"mappings":";;AAAA;AACA;;;;AAGA;AAIA;EAMI;IALA,gBAAW,GAAG,KAAK;IACnB,mBAAc,GAAG,KAAK;IAKlB,IAAI,OAAOA,OAAO,KAAK,WAAW,EAAE;MAChC,IAAMC,UAAU,GAAGD,OAAO,CAAC,QAAQ,CAAC;MACpC,IAAIC,UAAU,IAAIA,UAAU,CAACC,WAAW,EAAE;QACtC,IAAI,CAACC,OAAO,GAAGF,UAAU;QACzB,IAAI,CAACG,WAAW,GAAG,IAAI;QACvB,IAAI,CAACC,cAAc,GAAG,IAAI;;;EAGtC;EAEAC,sCAAW,GAAX,UAAYC,MAAc;IACtB,IAAI,CAAC,IAAI,CAACH,WAAW,IAAI,CAAC,IAAI,CAACD,OAAO,EAAE;MACpC,MAAM,IAAIK,KAAK,CAAC,iDAAiD,CAAC;;IAGtE;IACA,IAAIC,MAAM,GAAG,IAAI,CAACN,OAAO,CAACD,WAAW,CAACK,MAAM,CAAC;IAE7C;IACA,IAAIE,MAAM,CAACF,MAAM,KAAKA,MAAM,EAAE;MAC1B,MAAM,IAAIC,KAAK,CAAC,kDAAkD,CAAC;;IAGvE;IACA,IAAME,GAAG,GAAG,IAAIC,UAAU,CAACJ,MAAM,CAAC;IAElC;IACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,CAACH,MAAM,EAAEK,CAAC,EAAE,EAAE;MACjCF,GAAG,CAACE,CAAC,CAAC,GAAGH,MAAM,CAACG,CAAC,CAAC;;IAGtB;IACAC,WAAI,CAACJ,MAAM,CAAC;IAEZ,OAAOC,GAAG;EACd,CAAC;EACL,uBAAC;AAAD,CAAC,EA3CD;AAAaI","names":["require","nodeCrypto","randomBytes","_crypto","isAvailable","isInstantiated","NodeRandomSource","length","Error","buffer","out","Uint8Array","i","wipe_1","exports"],"sources":["/Users/user/Desktop/solana-hack-1/client/node_modules/@walletconnect/utils/node_modules/@stablelib/random/source/node.ts"],"sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nimport { RandomSource } from \"./\";\nimport { wipe } from \"@stablelib/wipe\";\n\ndeclare function require(name: string): any;\n\nexport class NodeRandomSource implements RandomSource {\n    isAvailable = false;\n    isInstantiated = false;\n\n    private _crypto: { randomBytes(n: number): Uint8Array } | undefined;\n\n    constructor() {\n        if (typeof require !== \"undefined\") {\n            const nodeCrypto = require(\"crypto\");\n            if (nodeCrypto && nodeCrypto.randomBytes) {\n                this._crypto = nodeCrypto;\n                this.isAvailable = true;\n                this.isInstantiated = true;\n            }\n        }\n    }\n\n    randomBytes(length: number): Uint8Array {\n        if (!this.isAvailable || !this._crypto) {\n            throw new Error(\"Node.js random byte generator is not available.\");\n        }\n\n        // Get random bytes (result is Buffer).\n        let buffer = this._crypto.randomBytes(length);\n\n        // Make sure we got the length that we requested.\n        if (buffer.length !== length) {\n            throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n        }\n\n        // Allocate output array.\n        const out = new Uint8Array(length);\n\n        // Copy bytes from buffer to output.\n        for (let i = 0; i < out.length; i++) {\n            out[i] = buffer[i];\n        }\n\n        // Cleanup.\n        wipe(buffer);\n\n        return out;\n    }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}