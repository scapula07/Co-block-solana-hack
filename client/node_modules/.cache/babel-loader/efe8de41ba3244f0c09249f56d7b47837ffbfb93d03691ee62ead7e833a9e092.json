{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainDecoderPart = void 0;\nconst utils_1 = require(\"./utils\");\nconst fountainUtils_1 = require(\"./fountainUtils\");\nconst errors_1 = require(\"./errors\");\nclass FountainDecoderPart {\n  constructor(_indexes, _fragment) {\n    this._indexes = _indexes;\n    this._fragment = _fragment;\n  }\n  get indexes() {\n    return this._indexes;\n  }\n  get fragment() {\n    return this._fragment;\n  }\n  static fromEncoderPart(encoderPart) {\n    const indexes = fountainUtils_1.chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n    const fragment = encoderPart.fragment;\n    return new FountainDecoderPart(indexes, fragment);\n  }\n  isSimple() {\n    return this.indexes.length === 1;\n  }\n}\nexports.FountainDecoderPart = FountainDecoderPart;\nclass FountainDecoder {\n  constructor() {\n    this.result = undefined;\n    this.expectedMessageLength = 0;\n    this.expectedChecksum = 0;\n    this.expectedFragmentLength = 0;\n    this.processedPartsCount = 0;\n    this.expectedPartIndexes = [];\n    this.lastPartIndexes = [];\n    this.queuedParts = [];\n    this.receivedPartIndexes = [];\n    this.mixedParts = [];\n    this.simpleParts = [];\n  }\n  validatePart(part) {\n    // If this is the first part we've seen\n    if (this.expectedPartIndexes.length === 0) {\n      // Record the things that all the other parts we see will have to match to be valid.\n      [...new Array(part.seqLength)].forEach((_, index) => this.expectedPartIndexes.push(index));\n      this.expectedMessageLength = part.messageLength;\n      this.expectedChecksum = part.checksum;\n      this.expectedFragmentLength = part.fragment.length;\n    } else {\n      // If this part's values don't match the first part's values, throw away the part\n      if (this.expectedPartIndexes.length !== part.seqLength) {\n        return false;\n      }\n      if (this.expectedMessageLength !== part.messageLength) {\n        return false;\n      }\n      if (this.expectedChecksum !== part.checksum) {\n        return false;\n      }\n      if (this.expectedFragmentLength !== part.fragment.length) {\n        return false;\n      }\n    }\n    // This part should be processed\n    return true;\n  }\n  reducePartByPart(a, b) {\n    // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n    if (utils_1.arrayContains(a.indexes, b.indexes)) {\n      const newIndexes = utils_1.setDifference(a.indexes, b.indexes);\n      const newFragment = utils_1.bufferXOR(a.fragment, b.fragment);\n      return new FountainDecoderPart(newIndexes, newFragment);\n    } else {\n      // `a` is not reducable by `b`, so return a\n      return a;\n    }\n  }\n  reduceMixedBy(part) {\n    const newMixed = [];\n    this.mixedParts.map(_ref => {\n      let {\n        value: mixedPart\n      } = _ref;\n      return this.reducePartByPart(mixedPart, part);\n    }).forEach(reducedPart => {\n      if (reducedPart.isSimple()) {\n        this.queuedParts.push(reducedPart);\n      } else {\n        newMixed.push({\n          key: reducedPart.indexes,\n          value: reducedPart\n        });\n      }\n    });\n    this.mixedParts = newMixed;\n  }\n  processSimplePart(part) {\n    // Don't process duplicate parts\n    const fragmentIndex = part.indexes[0];\n    if (this.receivedPartIndexes.includes(fragmentIndex)) {\n      return;\n    }\n    this.simpleParts.push({\n      key: part.indexes,\n      value: part\n    });\n    this.receivedPartIndexes.push(fragmentIndex);\n    // If we've received all the parts\n    if (utils_1.arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n      // Reassemble the message from its fragments\n      const sortedParts = this.simpleParts.map(_ref2 => {\n        let {\n          value\n        } = _ref2;\n        return value;\n      }).sort((a, b) => a.indexes[0] - b.indexes[0]);\n      const message = FountainDecoder.joinFragments(sortedParts.map(part => part.fragment), this.expectedMessageLength);\n      const checksum = utils_1.getCRC(message);\n      if (checksum === this.expectedChecksum) {\n        this.result = message;\n      } else {\n        this.error = new errors_1.InvalidChecksumError();\n      }\n    } else {\n      this.reduceMixedBy(part);\n    }\n  }\n  processMixedPart(part) {\n    // Don't process duplicate parts\n    if (this.mixedParts.some(_ref3 => {\n      let {\n        key: indexes\n      } = _ref3;\n      return utils_1.arraysEqual(indexes, part.indexes);\n    })) {\n      return;\n    }\n    // Reduce this part by all the others\n    let p2 = this.simpleParts.reduce((acc, _ref4) => {\n      let {\n        value: p\n      } = _ref4;\n      return this.reducePartByPart(acc, p);\n    }, part);\n    p2 = this.mixedParts.reduce((acc, _ref5) => {\n      let {\n        value: p\n      } = _ref5;\n      return this.reducePartByPart(acc, p);\n    }, p2);\n    // If the part is now simple\n    if (p2.isSimple()) {\n      // Add it to the queue\n      this.queuedParts.push(p2);\n    } else {\n      this.reduceMixedBy(p2);\n      this.mixedParts.push({\n        key: p2.indexes,\n        value: p2\n      });\n    }\n  }\n  processQueuedItem() {\n    if (this.queuedParts.length === 0) {\n      return;\n    }\n    const part = this.queuedParts.shift();\n    if (part.isSimple()) {\n      this.processSimplePart(part);\n    } else {\n      this.processMixedPart(part);\n    }\n  }\n  receivePart(encoderPart) {\n    if (this.isComplete()) {\n      return false;\n    }\n    if (!this.validatePart(encoderPart)) {\n      return false;\n    }\n    const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n    this.lastPartIndexes = decoderPart.indexes;\n    this.queuedParts.push(decoderPart);\n    while (!this.isComplete() && this.queuedParts.length > 0) {\n      this.processQueuedItem();\n    }\n    ;\n    this.processedPartsCount += 1;\n    return true;\n  }\n  isComplete() {\n    return Boolean(this.result !== undefined && this.result.length > 0);\n  }\n  isSuccess() {\n    return Boolean(this.error === undefined && this.isComplete());\n  }\n  resultMessage() {\n    return this.isSuccess() ? this.result : Buffer.from([]);\n  }\n  isFailure() {\n    return this.error !== undefined;\n  }\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n  expectedPartCount() {\n    return this.expectedPartIndexes.length;\n  }\n  getExpectedPartIndexes() {\n    return [...this.expectedPartIndexes];\n  }\n  getReceivedPartIndexes() {\n    return [...this.receivedPartIndexes];\n  }\n  getLastPartIndexes() {\n    return [...this.lastPartIndexes];\n  }\n  estimatedPercentComplete() {\n    if (this.isComplete()) {\n      return 1;\n    }\n    const expectedPartCount = this.expectedPartCount();\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n    // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n    // that `this.processedPartsCount` also tracks the duplicate parts that have been\n    // processeed.\n    return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n  }\n  getProgress() {\n    if (this.isComplete()) {\n      return 1;\n    }\n    const expectedPartCount = this.expectedPartCount();\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n    return this.receivedPartIndexes.length / expectedPartCount;\n  }\n}\nexports.default = FountainDecoder;\nFountainDecoder.joinFragments = (fragments, messageLength) => {\n  return Buffer.concat(fragments).slice(0, messageLength);\n};","map":{"version":3,"mappings":"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","names":["FountainDecoderPart","constructor","_indexes","_fragment","indexes","fragment","fromEncoderPart","encoderPart","fountainUtils_1","seqNum","seqLength","checksum","isSimple","length","exports","FountainDecoder","undefined","validatePart","part","expectedPartIndexes","Array","forEach","_","index","push","expectedMessageLength","messageLength","expectedChecksum","expectedFragmentLength","reducePartByPart","a","b","utils_1","newIndexes","newFragment","reduceMixedBy","newMixed","mixedParts","map","value","mixedPart","reducedPart","queuedParts","key","processSimplePart","fragmentIndex","receivedPartIndexes","includes","simpleParts","sortedParts","sort","message","joinFragments","result","error","errors_1","processMixedPart","some","p2","reduce","acc","p","processQueuedItem","shift","receivePart","isComplete","decoderPart","lastPartIndexes","processedPartsCount","Boolean","isSuccess","resultMessage","Buffer","from","isFailure","resultError","expectedPartCount","getExpectedPartIndexes","getReceivedPartIndexes","getLastPartIndexes","estimatedPercentComplete","Math","min","getProgress","fragments","concat","slice"],"sources":["/Users/user/Desktop/solana-hack-1/solana-payroll/node_modules/@ngraveio/bc-ur/src/fountainDecoder.ts"],"sourcesContent":["import { arrayContains, arraysEqual, bufferXOR, getCRC, setDifference, split } from \"./utils\";\nimport { chooseFragments } from \"./fountainUtils\";\nimport { FountainEncoderPart } from \"./fountainEncoder\";\nimport { InvalidChecksumError } from \"./errors\";\n\nexport class FountainDecoderPart {\n  constructor(\n    private _indexes: number[],\n    private _fragment: Buffer\n  ) { }\n\n  get indexes() { return this._indexes; }\n  get fragment() { return this._fragment; }\n\n  public static fromEncoderPart(encoderPart: FountainEncoderPart) {\n    const indexes = chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n    const fragment = encoderPart.fragment;\n\n    return new FountainDecoderPart(indexes, fragment);\n  }\n\n  public isSimple() {\n    return this.indexes.length === 1;\n  }\n}\n\ntype PartIndexes = number[];\ninterface PartDict {\n  key: PartIndexes;\n  value: FountainDecoderPart;\n}\n\nexport default class FountainDecoder {\n  private error: Error | undefined;\n  private result: Buffer | undefined = undefined;\n  private expectedMessageLength: number = 0;\n  private expectedChecksum: number = 0;\n  private expectedFragmentLength: number = 0;\n  private processedPartsCount: number = 0;\n  private expectedPartIndexes: PartIndexes = [];\n  private lastPartIndexes: PartIndexes = [];\n  private queuedParts: FountainDecoderPart[] = [];\n  private receivedPartIndexes: PartIndexes = [];\n  private mixedParts: PartDict[] = [];\n  private simpleParts: PartDict[] = [];\n\n\n  private validatePart(part: FountainEncoderPart) {\n    // If this is the first part we've seen\n    if (this.expectedPartIndexes.length === 0) {\n      // Record the things that all the other parts we see will have to match to be valid.\n      [...new Array(part.seqLength)]\n        .forEach((_, index) => this.expectedPartIndexes.push(index));\n\n      this.expectedMessageLength = part.messageLength;\n      this.expectedChecksum = part.checksum;\n      this.expectedFragmentLength = part.fragment.length;\n    }\n    else {\n      // If this part's values don't match the first part's values, throw away the part\n      if (this.expectedPartIndexes.length !== part.seqLength) {\n        return false;\n      }\n      if (this.expectedMessageLength !== part.messageLength) {\n        return false;\n      }\n      if (this.expectedChecksum !== part.checksum) {\n        return false;\n      }\n      if (this.expectedFragmentLength !== part.fragment.length) {\n        return false;\n      }\n    }\n\n    // This part should be processed\n    return true;\n  }\n\n  private reducePartByPart(a: FountainDecoderPart, b: FountainDecoderPart): FountainDecoderPart {\n    // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n    if (arrayContains(a.indexes, b.indexes)) {\n      const newIndexes = setDifference(a.indexes, b.indexes);\n      const newFragment = bufferXOR(a.fragment, b.fragment);\n\n      return new FountainDecoderPart(newIndexes, newFragment);\n    } else {\n      // `a` is not reducable by `b`, so return a\n      return a;\n    }\n  }\n\n  private reduceMixedBy(part: FountainDecoderPart): void {\n    const newMixed: PartDict[] = [];\n\n    this.mixedParts\n      .map(({ value: mixedPart }) => this.reducePartByPart(mixedPart, part))\n      .forEach(reducedPart => {\n        if (reducedPart.isSimple()) {\n          this.queuedParts.push(reducedPart)\n        } else {\n          newMixed.push({ key: reducedPart.indexes, value: reducedPart })\n        }\n      })\n\n    this.mixedParts = newMixed;\n  }\n\n  private processSimplePart(part: FountainDecoderPart): void {\n    // Don't process duplicate parts\n    const fragmentIndex = part.indexes[0]\n\n    if (this.receivedPartIndexes.includes(fragmentIndex)) {\n      return;\n    }\n\n    this.simpleParts.push({ key: part.indexes, value: part });\n    this.receivedPartIndexes.push(fragmentIndex);\n\n    // If we've received all the parts\n    if (arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n      // Reassemble the message from its fragments\n      const sortedParts = this.simpleParts\n        .map(({ value }) => value)\n        .sort((a, b) => (a.indexes[0] - b.indexes[0]))\n      const message = FountainDecoder.joinFragments(sortedParts.map(part => part.fragment), this.expectedMessageLength)\n      const checksum = getCRC(message);\n\n      if (checksum === this.expectedChecksum) {\n        this.result = message;\n      } else {\n        this.error = new InvalidChecksumError();\n      }\n    }\n    else {\n      this.reduceMixedBy(part);\n    }\n  }\n\n  private processMixedPart(part: FountainDecoderPart): void {\n    // Don't process duplicate parts\n    if (this.mixedParts.some(({ key: indexes }) => arraysEqual(indexes, part.indexes))) {\n      return;\n    }\n\n    // Reduce this part by all the others\n    let p2 = this.simpleParts.reduce((acc, { value: p }) => this.reducePartByPart(acc, p), part)\n    p2 = this.mixedParts.reduce((acc, { value: p }) => this.reducePartByPart(acc, p), p2)\n\n    // If the part is now simple\n    if (p2.isSimple()) {\n      // Add it to the queue\n      this.queuedParts.push(p2);\n    } else {\n      this.reduceMixedBy(p2);\n\n      this.mixedParts.push({ key: p2.indexes, value: p2 });\n    }\n  }\n\n  private processQueuedItem(): void {\n    if (this.queuedParts.length === 0) {\n      return;\n    }\n\n    const part = this.queuedParts.shift()!;\n\n    if (part.isSimple()) {\n      this.processSimplePart(part);\n    } else {\n      this.processMixedPart(part);\n    }\n  }\n\n  public static joinFragments = (fragments: Buffer[], messageLength: number) => {\n    return Buffer.concat(fragments).slice(0, messageLength)\n  }\n\n  public receivePart(encoderPart: FountainEncoderPart): boolean {\n    if (this.isComplete()) {\n      return false;\n    }\n\n    if (!this.validatePart(encoderPart)) {\n      return false;\n    }\n\n    const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n\n    this.lastPartIndexes = decoderPart.indexes;\n    this.queuedParts.push(decoderPart);\n\n    while (!this.isComplete() && this.queuedParts.length > 0) {\n      this.processQueuedItem();\n    };\n\n    this.processedPartsCount += 1;\n\n    return true;\n  }\n\n  public isComplete() {\n    return Boolean(this.result !== undefined && this.result.length > 0);\n  }\n\n  public isSuccess() {\n    return Boolean(this.error === undefined && this.isComplete());\n  }\n\n  public resultMessage(): Buffer {\n    return this.isSuccess() ? this.result! : Buffer.from([]);\n  }\n\n  public isFailure() {\n    return this.error !== undefined;\n  }\n\n  public resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  public expectedPartCount(): number {\n    return this.expectedPartIndexes.length;\n  }\n\n  public getExpectedPartIndexes(): PartIndexes {\n    return [...this.expectedPartIndexes]\n  }\n\n  public getReceivedPartIndexes(): PartIndexes {\n    return [...this.receivedPartIndexes]\n  }\n\n  public getLastPartIndexes(): PartIndexes {\n    return [...this.lastPartIndexes]\n  }\n\n  public estimatedPercentComplete(): number {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n\n    // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n    // that `this.processedPartsCount` also tracks the duplicate parts that have been\n    // processeed.\n    return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n  }\n\n  public getProgress(): number {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n\n    return this.receivedPartIndexes.length / expectedPartCount;\n  }\n}\n\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}