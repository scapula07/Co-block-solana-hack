{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoKeypath = void 0;\nconst lib_1 = require(\"./lib\");\nconst PathComponent_1 = require(\"./PathComponent\");\nconst RegistryItem_1 = require(\"./RegistryItem\");\nconst RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n  Keys[Keys[\"components\"] = 1] = \"components\";\n  Keys[Keys[\"source_fingerprint\"] = 2] = \"source_fingerprint\";\n  Keys[Keys[\"depth\"] = 3] = \"depth\";\n})(Keys || (Keys = {}));\nclass CryptoKeypath extends RegistryItem_1.RegistryItem {\n  constructor() {\n    let components = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let sourceFingerprint = arguments.length > 1 ? arguments[1] : undefined;\n    let depth = arguments.length > 2 ? arguments[2] : undefined;\n    super();\n    this.components = components;\n    this.sourceFingerprint = sourceFingerprint;\n    this.depth = depth;\n    this.getRegistryType = () => {\n      return RegistryType_1.RegistryTypes.CRYPTO_KEYPATH;\n    };\n    this.getPath = () => {\n      if (this.components.length === 0) {\n        return undefined;\n      }\n      const components = this.components.map(component => {\n        return `${component.isWildcard() ? '*' : component.getIndex()}${component.isHardened() ? \"'\" : ''}`;\n      });\n      return components.join('/');\n    };\n    this.getComponents = () => this.components;\n    this.getSourceFingerprint = () => this.sourceFingerprint;\n    this.getDepth = () => this.depth;\n    this.toDataItem = () => {\n      const map = {};\n      const components = [];\n      this.components && this.components.forEach(component => {\n        if (component.isWildcard()) {\n          components.push([]);\n        } else {\n          components.push(component.getIndex());\n        }\n        components.push(component.isHardened());\n      });\n      map[Keys.components] = components;\n      if (this.sourceFingerprint) {\n        map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);\n      }\n      if (this.depth !== undefined) {\n        map[Keys.depth] = this.depth;\n      }\n      return new lib_1.DataItem(map);\n    };\n  }\n}\nexports.CryptoKeypath = CryptoKeypath;\nCryptoKeypath.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const pathComponents = [];\n  const components = map[Keys.components];\n  if (components) {\n    for (let i = 0; i < components.length; i += 2) {\n      const isHardened = components[i + 1];\n      const path = components[i];\n      if (typeof path === 'number') {\n        pathComponents.push(new PathComponent_1.PathComponent({\n          index: path,\n          hardened: isHardened\n        }));\n      } else {\n        pathComponents.push(new PathComponent_1.PathComponent({\n          hardened: isHardened\n        }));\n      }\n    }\n  }\n  const _sourceFingerprint = map[Keys.source_fingerprint];\n  let sourceFingerprint;\n  if (_sourceFingerprint) {\n    sourceFingerprint = Buffer.alloc(4);\n    sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);\n  }\n  const depth = map[Keys.depth];\n  return new CryptoKeypath(pathComponents, sourceFingerprint, depth);\n};\nCryptoKeypath.fromCBOR = _cborPayload => {\n  const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoKeypath.fromDataItem(dataItem);\n};","map":{"version":3,"mappings":"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","names":["Keys","CryptoKeypath","RegistryItem_1","constructor","components","sourceFingerprint","depth","RegistryType_1","CRYPTO_KEYPATH","length","undefined","map","component","isWildcard","getIndex","isHardened","join","forEach","push","source_fingerprint","readUInt32BE","lib_1","exports","dataItem","getData","pathComponents","i","path","PathComponent_1","index","hardened","_sourceFingerprint","Buffer","alloc","writeUInt32BE","_cborPayload","fromDataItem"],"sources":["/Users/user/Desktop/solana-hack-1/client/node_modules/@keystonehq/bc-ur-registry/src/CryptoKeypath.ts"],"sourcesContent":["import { decodeToDataItem, DataItem } from './lib';\nimport { PathComponent } from './PathComponent';\nimport { RegistryItem } from './RegistryItem';\nimport { RegistryTypes } from './RegistryType';\nimport { DataItemMap } from './types';\n\nenum Keys {\n  components = 1,\n  source_fingerprint,\n  depth,\n}\n\nexport class CryptoKeypath extends RegistryItem {\n  getRegistryType = () => {\n    return RegistryTypes.CRYPTO_KEYPATH;\n  };\n\n  constructor(\n    private components: PathComponent[] = [],\n    private sourceFingerprint?: Buffer,\n    private depth?: number,\n  ) {\n    super();\n  }\n\n  public getPath = () => {\n    if (this.components.length === 0) {\n      return undefined;\n    }\n\n    const components = this.components.map((component) => {\n      return `${component.isWildcard() ? '*' : component.getIndex()}${\n        component.isHardened() ? \"'\" : ''\n      }`;\n    });\n    return components.join('/');\n  };\n\n  public getComponents = () => this.components;\n  public getSourceFingerprint = () => this.sourceFingerprint;\n  public getDepth = () => this.depth;\n\n  toDataItem = () => {\n    const map: DataItemMap = {};\n    const components: (number | boolean | any[])[] = [];\n    this.components &&\n      this.components.forEach((component) => {\n        if (component.isWildcard()) {\n          components.push([]);\n        } else {\n          components.push(component.getIndex() as number);\n        }\n        components.push(component.isHardened());\n      });\n    map[Keys.components] = components;\n    if (this.sourceFingerprint) {\n      map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);\n    }\n    if (this.depth !== undefined) {\n      map[Keys.depth] = this.depth;\n    }\n    return new DataItem(map);\n  };\n\n  static fromDataItem = (dataItem: DataItem) => {\n    const map: Record<string, any> = dataItem.getData();\n    const pathComponents: PathComponent[] = [];\n    const components = map[Keys.components] as any[];\n    if (components) {\n      for (let i = 0; i < components.length; i += 2) {\n        const isHardened = components[i + 1];\n        const path = components[i];\n        if (typeof path === 'number') {\n          pathComponents.push(\n            new PathComponent({ index: path, hardened: isHardened }),\n          );\n        } else {\n          pathComponents.push(new PathComponent({ hardened: isHardened }));\n        }\n      }\n    }\n    const _sourceFingerprint = map[Keys.source_fingerprint];\n    let sourceFingerprint: Buffer | undefined;\n    if (_sourceFingerprint) {\n      sourceFingerprint = Buffer.alloc(4);\n      sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);\n    }\n    const depth = map[Keys.depth];\n    return new CryptoKeypath(pathComponents, sourceFingerprint, depth);\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoKeypath.fromDataItem(dataItem);\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}