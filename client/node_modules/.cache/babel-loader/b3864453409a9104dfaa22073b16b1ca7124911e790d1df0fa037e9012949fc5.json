{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainEncoderPart = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst utils_1 = require(\"./utils\");\nconst fountainUtils_1 = require(\"./fountainUtils\");\nconst cbor_1 = require(\"./cbor\");\nclass FountainEncoderPart {\n  constructor(_seqNum, _seqLength, _messageLength, _checksum, _fragment) {\n    this._seqNum = _seqNum;\n    this._seqLength = _seqLength;\n    this._messageLength = _messageLength;\n    this._checksum = _checksum;\n    this._fragment = _fragment;\n  }\n  get messageLength() {\n    return this._messageLength;\n  }\n  get fragment() {\n    return this._fragment;\n  }\n  get seqNum() {\n    return this._seqNum;\n  }\n  get seqLength() {\n    return this._seqLength;\n  }\n  get checksum() {\n    return this._checksum;\n  }\n  cbor() {\n    const result = cbor_1.cborEncode([this._seqNum, this._seqLength, this._messageLength, this._checksum, this._fragment]);\n    return Buffer.from(result);\n  }\n  description() {\n    return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString('hex')}`;\n  }\n  static fromCBOR(cborPayload) {\n    const [seqNum, seqLength, messageLength, checksum, fragment] = cbor_1.cborDecode(cborPayload);\n    assert_1.default(typeof seqNum === 'number');\n    assert_1.default(typeof seqLength === 'number');\n    assert_1.default(typeof messageLength === 'number');\n    assert_1.default(typeof checksum === 'number');\n    assert_1.default(Buffer.isBuffer(fragment) && fragment.length > 0);\n    return new FountainEncoderPart(seqNum, seqLength, messageLength, checksum, Buffer.from(fragment));\n  }\n}\nexports.FountainEncoderPart = FountainEncoderPart;\nclass FountainEncoder {\n  constructor(message) {\n    let maxFragmentLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    let firstSeqNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let minFragmentLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n    const fragmentLength = FountainEncoder.findNominalFragmentLength(message.length, minFragmentLength, maxFragmentLength);\n    this._messageLength = message.length;\n    this._fragments = FountainEncoder.partitionMessage(message, fragmentLength);\n    this.fragmentLength = fragmentLength;\n    this.seqNum = utils_1.toUint32(firstSeqNum);\n    this.checksum = utils_1.getCRC(message);\n  }\n  get fragmentsLength() {\n    return this._fragments.length;\n  }\n  get fragments() {\n    return this._fragments;\n  }\n  get messageLength() {\n    return this._messageLength;\n  }\n  isComplete() {\n    return this.seqNum >= this._fragments.length;\n  }\n  isSinglePart() {\n    return this._fragments.length === 1;\n  }\n  seqLength() {\n    return this._fragments.length;\n  }\n  mix(indexes) {\n    return indexes.reduce((result, index) => utils_1.bufferXOR(this._fragments[index], result), Buffer.alloc(this.fragmentLength, 0));\n  }\n  nextPart() {\n    this.seqNum = utils_1.toUint32(this.seqNum + 1);\n    const indexes = fountainUtils_1.chooseFragments(this.seqNum, this._fragments.length, this.checksum);\n    const mixed = this.mix(indexes);\n    return new FountainEncoderPart(this.seqNum, this._fragments.length, this._messageLength, this.checksum, mixed);\n  }\n  static findNominalFragmentLength(messageLength, minFragmentLength, maxFragmentLength) {\n    assert_1.default(messageLength > 0);\n    assert_1.default(minFragmentLength > 0);\n    assert_1.default(maxFragmentLength >= minFragmentLength);\n    const maxFragmentCount = Math.ceil(messageLength / minFragmentLength);\n    let fragmentLength = 0;\n    for (let fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++) {\n      fragmentLength = Math.ceil(messageLength / fragmentCount);\n      if (fragmentLength <= maxFragmentLength) {\n        break;\n      }\n    }\n    return fragmentLength;\n  }\n  static partitionMessage(message, fragmentLength) {\n    let remaining = Buffer.from(message);\n    let fragment;\n    let _fragments = [];\n    while (remaining.length > 0) {\n      [fragment, remaining] = utils_1.split(remaining, -fragmentLength);\n      fragment = Buffer.alloc(fragmentLength, 0) // initialize with 0's to achieve the padding\n      .fill(fragment, 0, fragment.length);\n      _fragments.push(fragment);\n    }\n    return _fragments;\n  }\n}\nexports.default = FountainEncoder;","map":{"version":3,"mappings":"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","names":["FountainEncoderPart","constructor","_seqNum","_seqLength","_messageLength","_checksum","_fragment","messageLength","fragment","seqNum","seqLength","checksum","cbor","result","cbor_1","Buffer","from","description","toString","fromCBOR","cborPayload","assert_1","isBuffer","length","exports","FountainEncoder","message","maxFragmentLength","firstSeqNum","minFragmentLength","fragmentLength","findNominalFragmentLength","_fragments","partitionMessage","utils_1","fragmentsLength","fragments","isComplete","isSinglePart","mix","indexes","reduce","index","alloc","nextPart","fountainUtils_1","mixed","maxFragmentCount","Math","ceil","fragmentCount","remaining","fill","push"],"sources":["/Users/user/Desktop/solana-hack-1/client/node_modules/@ngraveio/bc-ur/src/fountainEncoder.ts"],"sourcesContent":["import assert from \"assert\";\nimport { bufferXOR, getCRC, split, toUint32 } from \"./utils\";\nimport { chooseFragments } from \"./fountainUtils\";\nimport { cborEncode, cborDecode } from './cbor';\n\nexport class FountainEncoderPart {\n  constructor(\n    private _seqNum: number,\n    private _seqLength: number,\n    private _messageLength: number,\n    private _checksum: number,\n    private _fragment: Buffer,\n  ) { }\n\n  get messageLength() { return this._messageLength; }\n  get fragment() { return this._fragment; }\n  get seqNum() { return this._seqNum; }\n  get seqLength() { return this._seqLength; }\n  get checksum() { return this._checksum; }\n\n  public cbor(): Buffer {\n    const result = cborEncode([\n      this._seqNum,\n      this._seqLength,\n      this._messageLength,\n      this._checksum,\n      this._fragment\n    ])\n\n    return Buffer.from(result);\n  }\n\n  public description(): string {\n    return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString('hex')}`\n  }\n\n  public static fromCBOR(cborPayload: string | Buffer) {\n    const [\n      seqNum,\n      seqLength,\n      messageLength,\n      checksum,\n      fragment,\n    ] = cborDecode(cborPayload);\n\n    assert(typeof seqNum === 'number');\n    assert(typeof seqLength === 'number');\n    assert(typeof messageLength === 'number');\n    assert(typeof checksum === 'number');\n    assert(Buffer.isBuffer(fragment) && fragment.length > 0);\n\n    return new FountainEncoderPart(\n      seqNum,\n      seqLength,\n      messageLength,\n      checksum,\n      Buffer.from(fragment),\n    )\n  }\n}\n\nexport default class FountainEncoder {\n  private _messageLength: number;\n  private _fragments: Buffer[];\n  private fragmentLength: number;\n  private seqNum: number;\n  private checksum: number;\n\n  constructor(\n    message: Buffer,\n    maxFragmentLength: number = 100,\n    firstSeqNum: number = 0,\n    minFragmentLength: number = 10\n  ) {\n    const fragmentLength = FountainEncoder.findNominalFragmentLength(message.length, minFragmentLength, maxFragmentLength);\n\n    this._messageLength = message.length;\n    this._fragments = FountainEncoder.partitionMessage(message, fragmentLength);\n    this.fragmentLength = fragmentLength;\n    this.seqNum = toUint32(firstSeqNum);\n    this.checksum = getCRC(message)\n  }\n\n  public get fragmentsLength() { return this._fragments.length; }\n  public get fragments() { return this._fragments; }\n  public get messageLength() { return this._messageLength; }\n\n  public isComplete(): boolean {\n    return this.seqNum >= this._fragments.length;\n  }\n\n  public isSinglePart(): boolean {\n    return this._fragments.length === 1;\n  }\n\n  public seqLength(): number {\n    return this._fragments.length;\n  }\n\n  public mix(indexes: number[]) {\n    return indexes.reduce(\n      (result, index) => bufferXOR(this._fragments[index], result),\n      Buffer.alloc(this.fragmentLength, 0)\n    )\n  }\n\n  public nextPart(): FountainEncoderPart {\n    this.seqNum = toUint32(this.seqNum + 1);\n\n    const indexes = chooseFragments(this.seqNum, this._fragments.length, this.checksum);\n    const mixed = this.mix(indexes);\n\n    return new FountainEncoderPart(\n      this.seqNum,\n      this._fragments.length,\n      this._messageLength,\n      this.checksum,\n      mixed\n    )\n  }\n\n  public static findNominalFragmentLength(\n    messageLength: number,\n    minFragmentLength: number,\n    maxFragmentLength: number\n  ): number {\n    assert(messageLength > 0)\n    assert(minFragmentLength > 0)\n    assert(maxFragmentLength >= minFragmentLength)\n\n    const maxFragmentCount = Math.ceil(messageLength / minFragmentLength);\n    let fragmentLength = 0;\n\n    for (let fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++) {\n      fragmentLength = Math.ceil(messageLength / fragmentCount);\n\n      if (fragmentLength <= maxFragmentLength) {\n        break;\n      }\n    }\n\n    return fragmentLength;\n  }\n\n  public static partitionMessage(message: Buffer, fragmentLength: number): Buffer[] {\n    let remaining = Buffer.from(message);\n    let fragment;\n    let _fragments: Buffer[] = [];\n\n    while (remaining.length > 0) {\n      [fragment, remaining] = split(remaining, -fragmentLength)\n      fragment = Buffer\n        .alloc(fragmentLength, 0) // initialize with 0's to achieve the padding\n        .fill(fragment, 0, fragment.length)\n      _fragments.push(fragment)\n    }\n\n    return _fragments;\n  }\n}\n\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}