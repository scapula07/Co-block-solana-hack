{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;\nconst h264 = __importStar(require(\"h264-profile-level-id\"));\nconst utils = __importStar(require(\"./utils\"));\nconst RTP_PROBATOR_MID = 'probator';\nconst RTP_PROBATOR_SSRC = 1234;\nconst RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\n/**\n * Validates RtpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCapabilities(caps) {\n  if (typeof caps !== 'object') throw new TypeError('caps is not an object');\n  // codecs is optional. If unset, fill with an empty array.\n  if (caps.codecs && !Array.isArray(caps.codecs)) throw new TypeError('caps.codecs is not an array');else if (!caps.codecs) caps.codecs = [];\n  for (const codec of caps.codecs) {\n    validateRtpCodecCapability(codec);\n  }\n  // headerExtensions is optional. If unset, fill with an empty array.\n  if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) throw new TypeError('caps.headerExtensions is not an array');else if (!caps.headerExtensions) caps.headerExtensions = [];\n  for (const ext of caps.headerExtensions) {\n    validateRtpHeaderExtension(ext);\n  }\n}\nexports.validateRtpCapabilities = validateRtpCapabilities;\n/**\n * Validates RtpCodecCapability. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecCapability(codec) {\n  const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n  if (typeof codec !== 'object') throw new TypeError('codec is not an object');\n  // mimeType is mandatory.\n  if (!codec.mimeType || typeof codec.mimeType !== 'string') throw new TypeError('missing codec.mimeType');\n  const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n  if (!mimeTypeMatch) throw new TypeError('invalid codec.mimeType');\n  // Just override kind with media component of mimeType.\n  codec.kind = mimeTypeMatch[1].toLowerCase();\n  // preferredPayloadType is optional.\n  if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number') throw new TypeError('invalid codec.preferredPayloadType');\n  // clockRate is mandatory.\n  if (typeof codec.clockRate !== 'number') throw new TypeError('missing codec.clockRate');\n  // channels is optional. If unset, set it to 1 (just if audio).\n  if (codec.kind === 'audio') {\n    if (typeof codec.channels !== 'number') codec.channels = 1;\n  } else {\n    delete codec.channels;\n  }\n  // parameters is optional. If unset, set it to an empty object.\n  if (!codec.parameters || typeof codec.parameters !== 'object') codec.parameters = {};\n  for (const key of Object.keys(codec.parameters)) {\n    let value = codec.parameters[key];\n    if (value === undefined) {\n      codec.parameters[key] = '';\n      value = '';\n    }\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n    }\n    // Specific parameters validation.\n    if (key === 'apt') {\n      if (typeof value !== 'number') throw new TypeError('invalid codec apt parameter');\n    }\n  }\n  // rtcpFeedback is optional. If unset, set it to an empty array.\n  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) codec.rtcpFeedback = [];\n  for (const fb of codec.rtcpFeedback) {\n    validateRtcpFeedback(fb);\n  }\n}\nexports.validateRtpCodecCapability = validateRtpCodecCapability;\n/**\n * Validates RtcpFeedback. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpFeedback(fb) {\n  if (typeof fb !== 'object') throw new TypeError('fb is not an object');\n  // type is mandatory.\n  if (!fb.type || typeof fb.type !== 'string') throw new TypeError('missing fb.type');\n  // parameter is optional. If unset set it to an empty string.\n  if (!fb.parameter || typeof fb.parameter !== 'string') fb.parameter = '';\n}\nexports.validateRtcpFeedback = validateRtcpFeedback;\n/**\n * Validates RtpHeaderExtension. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtension(ext) {\n  if (typeof ext !== 'object') throw new TypeError('ext is not an object');\n  // kind is mandatory.\n  if (ext.kind !== 'audio' && ext.kind !== 'video') throw new TypeError('invalid ext.kind');\n  // uri is mandatory.\n  if (!ext.uri || typeof ext.uri !== 'string') throw new TypeError('missing ext.uri');\n  // preferredId is mandatory.\n  if (typeof ext.preferredId !== 'number') throw new TypeError('missing ext.preferredId');\n  // preferredEncrypt is optional. If unset set it to false.\n  if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') throw new TypeError('invalid ext.preferredEncrypt');else if (!ext.preferredEncrypt) ext.preferredEncrypt = false;\n  // direction is optional. If unset set it to sendrecv.\n  if (ext.direction && typeof ext.direction !== 'string') throw new TypeError('invalid ext.direction');else if (!ext.direction) ext.direction = 'sendrecv';\n}\nexports.validateRtpHeaderExtension = validateRtpHeaderExtension;\n/**\n * Validates RtpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpParameters(params) {\n  if (typeof params !== 'object') throw new TypeError('params is not an object');\n  // mid is optional.\n  if (params.mid && typeof params.mid !== 'string') throw new TypeError('params.mid is not a string');\n  // codecs is mandatory.\n  if (!Array.isArray(params.codecs)) throw new TypeError('missing params.codecs');\n  for (const codec of params.codecs) {\n    validateRtpCodecParameters(codec);\n  }\n  // headerExtensions is optional. If unset, fill with an empty array.\n  if (params.headerExtensions && !Array.isArray(params.headerExtensions)) throw new TypeError('params.headerExtensions is not an array');else if (!params.headerExtensions) params.headerExtensions = [];\n  for (const ext of params.headerExtensions) {\n    validateRtpHeaderExtensionParameters(ext);\n  }\n  // encodings is optional. If unset, fill with an empty array.\n  if (params.encodings && !Array.isArray(params.encodings)) throw new TypeError('params.encodings is not an array');else if (!params.encodings) params.encodings = [];\n  for (const encoding of params.encodings) {\n    validateRtpEncodingParameters(encoding);\n  }\n  // rtcp is optional. If unset, fill with an empty object.\n  if (params.rtcp && typeof params.rtcp !== 'object') throw new TypeError('params.rtcp is not an object');else if (!params.rtcp) params.rtcp = {};\n  validateRtcpParameters(params.rtcp);\n}\nexports.validateRtpParameters = validateRtpParameters;\n/**\n * Validates RtpCodecParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecParameters(codec) {\n  const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n  if (typeof codec !== 'object') throw new TypeError('codec is not an object');\n  // mimeType is mandatory.\n  if (!codec.mimeType || typeof codec.mimeType !== 'string') throw new TypeError('missing codec.mimeType');\n  const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n  if (!mimeTypeMatch) throw new TypeError('invalid codec.mimeType');\n  // payloadType is mandatory.\n  if (typeof codec.payloadType !== 'number') throw new TypeError('missing codec.payloadType');\n  // clockRate is mandatory.\n  if (typeof codec.clockRate !== 'number') throw new TypeError('missing codec.clockRate');\n  const kind = mimeTypeMatch[1].toLowerCase();\n  // channels is optional. If unset, set it to 1 (just if audio).\n  if (kind === 'audio') {\n    if (typeof codec.channels !== 'number') codec.channels = 1;\n  } else {\n    delete codec.channels;\n  }\n  // parameters is optional. If unset, set it to an empty object.\n  if (!codec.parameters || typeof codec.parameters !== 'object') codec.parameters = {};\n  for (const key of Object.keys(codec.parameters)) {\n    let value = codec.parameters[key];\n    if (value === undefined) {\n      codec.parameters[key] = '';\n      value = '';\n    }\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n    }\n    // Specific parameters validation.\n    if (key === 'apt') {\n      if (typeof value !== 'number') throw new TypeError('invalid codec apt parameter');\n    }\n  }\n  // rtcpFeedback is optional. If unset, set it to an empty array.\n  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) codec.rtcpFeedback = [];\n  for (const fb of codec.rtcpFeedback) {\n    validateRtcpFeedback(fb);\n  }\n}\nexports.validateRtpCodecParameters = validateRtpCodecParameters;\n/**\n * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtensionParameters(ext) {\n  if (typeof ext !== 'object') throw new TypeError('ext is not an object');\n  // uri is mandatory.\n  if (!ext.uri || typeof ext.uri !== 'string') throw new TypeError('missing ext.uri');\n  // id is mandatory.\n  if (typeof ext.id !== 'number') throw new TypeError('missing ext.id');\n  // encrypt is optional. If unset set it to false.\n  if (ext.encrypt && typeof ext.encrypt !== 'boolean') throw new TypeError('invalid ext.encrypt');else if (!ext.encrypt) ext.encrypt = false;\n  // parameters is optional. If unset, set it to an empty object.\n  if (!ext.parameters || typeof ext.parameters !== 'object') ext.parameters = {};\n  for (const key of Object.keys(ext.parameters)) {\n    let value = ext.parameters[key];\n    if (value === undefined) {\n      ext.parameters[key] = '';\n      value = '';\n    }\n    if (typeof value !== 'string' && typeof value !== 'number') throw new TypeError('invalid header extension parameter');\n  }\n}\nexports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;\n/**\n * Validates RtpEncodingParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpEncodingParameters(encoding) {\n  if (typeof encoding !== 'object') throw new TypeError('encoding is not an object');\n  // ssrc is optional.\n  if (encoding.ssrc && typeof encoding.ssrc !== 'number') throw new TypeError('invalid encoding.ssrc');\n  // rid is optional.\n  if (encoding.rid && typeof encoding.rid !== 'string') throw new TypeError('invalid encoding.rid');\n  // rtx is optional.\n  if (encoding.rtx && typeof encoding.rtx !== 'object') {\n    throw new TypeError('invalid encoding.rtx');\n  } else if (encoding.rtx) {\n    // RTX ssrc is mandatory if rtx is present.\n    if (typeof encoding.rtx.ssrc !== 'number') throw new TypeError('missing encoding.rtx.ssrc');\n  }\n  // dtx is optional. If unset set it to false.\n  if (!encoding.dtx || typeof encoding.dtx !== 'boolean') encoding.dtx = false;\n  // scalabilityMode is optional.\n  if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string') throw new TypeError('invalid encoding.scalabilityMode');\n}\nexports.validateRtpEncodingParameters = validateRtpEncodingParameters;\n/**\n * Validates RtcpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpParameters(rtcp) {\n  if (typeof rtcp !== 'object') throw new TypeError('rtcp is not an object');\n  // cname is optional.\n  if (rtcp.cname && typeof rtcp.cname !== 'string') throw new TypeError('invalid rtcp.cname');\n  // reducedSize is optional. If unset set it to true.\n  if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') rtcp.reducedSize = true;\n}\nexports.validateRtcpParameters = validateRtcpParameters;\n/**\n * Validates SctpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpCapabilities(caps) {\n  if (typeof caps !== 'object') throw new TypeError('caps is not an object');\n  // numStreams is mandatory.\n  if (!caps.numStreams || typeof caps.numStreams !== 'object') throw new TypeError('missing caps.numStreams');\n  validateNumSctpStreams(caps.numStreams);\n}\nexports.validateSctpCapabilities = validateSctpCapabilities;\n/**\n * Validates NumSctpStreams. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateNumSctpStreams(numStreams) {\n  if (typeof numStreams !== 'object') throw new TypeError('numStreams is not an object');\n  // OS is mandatory.\n  if (typeof numStreams.OS !== 'number') throw new TypeError('missing numStreams.OS');\n  // MIS is mandatory.\n  if (typeof numStreams.MIS !== 'number') throw new TypeError('missing numStreams.MIS');\n}\nexports.validateNumSctpStreams = validateNumSctpStreams;\n/**\n * Validates SctpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpParameters(params) {\n  if (typeof params !== 'object') throw new TypeError('params is not an object');\n  // port is mandatory.\n  if (typeof params.port !== 'number') throw new TypeError('missing params.port');\n  // OS is mandatory.\n  if (typeof params.OS !== 'number') throw new TypeError('missing params.OS');\n  // MIS is mandatory.\n  if (typeof params.MIS !== 'number') throw new TypeError('missing params.MIS');\n  // maxMessageSize is mandatory.\n  if (typeof params.maxMessageSize !== 'number') throw new TypeError('missing params.maxMessageSize');\n}\nexports.validateSctpParameters = validateSctpParameters;\n/**\n * Validates SctpStreamParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpStreamParameters(params) {\n  if (typeof params !== 'object') throw new TypeError('params is not an object');\n  // streamId is mandatory.\n  if (typeof params.streamId !== 'number') throw new TypeError('missing params.streamId');\n  // ordered is optional.\n  let orderedGiven = false;\n  if (typeof params.ordered === 'boolean') orderedGiven = true;else params.ordered = true;\n  // maxPacketLifeTime is optional.\n  if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number') throw new TypeError('invalid params.maxPacketLifeTime');\n  // maxRetransmits is optional.\n  if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') throw new TypeError('invalid params.maxRetransmits');\n  if (params.maxPacketLifeTime && params.maxRetransmits) throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\n  if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {\n    throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\n  } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {\n    params.ordered = false;\n  }\n  // label is optional.\n  if (params.label && typeof params.label !== 'string') throw new TypeError('invalid params.label');\n  // protocol is optional.\n  if (params.protocol && typeof params.protocol !== 'string') throw new TypeError('invalid params.protocol');\n}\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\n/**\n * Generate extended RTP capabilities for sending and receiving.\n */\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps) {\n  const extendedRtpCapabilities = {\n    codecs: [],\n    headerExtensions: []\n  };\n  // Match media codecs and keep the order preferred by remoteCaps.\n  for (const remoteCodec of remoteCaps.codecs || []) {\n    if (isRtxCodec(remoteCodec)) continue;\n    const matchingLocalCodec = (localCaps.codecs || []).find(localCodec => matchCodecs(localCodec, remoteCodec, {\n      strict: true,\n      modify: true\n    }));\n    if (!matchingLocalCodec) continue;\n    const extendedCodec = {\n      mimeType: matchingLocalCodec.mimeType,\n      kind: matchingLocalCodec.kind,\n      clockRate: matchingLocalCodec.clockRate,\n      channels: matchingLocalCodec.channels,\n      localPayloadType: matchingLocalCodec.preferredPayloadType,\n      localRtxPayloadType: undefined,\n      remotePayloadType: remoteCodec.preferredPayloadType,\n      remoteRtxPayloadType: undefined,\n      localParameters: matchingLocalCodec.parameters,\n      remoteParameters: remoteCodec.parameters,\n      rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)\n    };\n    extendedRtpCapabilities.codecs.push(extendedCodec);\n  }\n  // Match RTX codecs.\n  for (const extendedCodec of extendedRtpCapabilities.codecs) {\n    const matchingLocalRtxCodec = localCaps.codecs.find(localCodec => isRtxCodec(localCodec) && localCodec.parameters.apt === extendedCodec.localPayloadType);\n    const matchingRemoteRtxCodec = remoteCaps.codecs.find(remoteCodec => isRtxCodec(remoteCodec) && remoteCodec.parameters.apt === extendedCodec.remotePayloadType);\n    if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\n      extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;\n      extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;\n    }\n  }\n  // Match header extensions.\n  for (const remoteExt of remoteCaps.headerExtensions) {\n    const matchingLocalExt = localCaps.headerExtensions.find(localExt => matchHeaderExtensions(localExt, remoteExt));\n    if (!matchingLocalExt) continue;\n    const extendedExt = {\n      kind: remoteExt.kind,\n      uri: remoteExt.uri,\n      sendId: matchingLocalExt.preferredId,\n      recvId: remoteExt.preferredId,\n      encrypt: matchingLocalExt.preferredEncrypt,\n      direction: 'sendrecv'\n    };\n    switch (remoteExt.direction) {\n      case 'sendrecv':\n        extendedExt.direction = 'sendrecv';\n        break;\n      case 'recvonly':\n        extendedExt.direction = 'sendonly';\n        break;\n      case 'sendonly':\n        extendedExt.direction = 'recvonly';\n        break;\n      case 'inactive':\n        extendedExt.direction = 'inactive';\n        break;\n    }\n    extendedRtpCapabilities.headerExtensions.push(extendedExt);\n  }\n  return extendedRtpCapabilities;\n}\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\n/**\n * Generate RTP capabilities for receiving media based on the given extended\n * RTP capabilities.\n */\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\n  const rtpCapabilities = {\n    codecs: [],\n    headerExtensions: []\n  };\n  for (const extendedCodec of extendedRtpCapabilities.codecs) {\n    const codec = {\n      mimeType: extendedCodec.mimeType,\n      kind: extendedCodec.kind,\n      preferredPayloadType: extendedCodec.remotePayloadType,\n      clockRate: extendedCodec.clockRate,\n      channels: extendedCodec.channels,\n      parameters: extendedCodec.localParameters,\n      rtcpFeedback: extendedCodec.rtcpFeedback\n    };\n    rtpCapabilities.codecs.push(codec);\n    // Add RTX codec.\n    if (!extendedCodec.remoteRtxPayloadType) continue;\n    const rtxCodec = {\n      mimeType: `${extendedCodec.kind}/rtx`,\n      kind: extendedCodec.kind,\n      preferredPayloadType: extendedCodec.remoteRtxPayloadType,\n      clockRate: extendedCodec.clockRate,\n      parameters: {\n        apt: extendedCodec.remotePayloadType\n      },\n      rtcpFeedback: []\n    };\n    rtpCapabilities.codecs.push(rtxCodec);\n    // TODO: In the future, we need to add FEC, CN, etc, codecs.\n  }\n\n  for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n    // Ignore RTP extensions not valid for receiving.\n    if (extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'recvonly') {\n      continue;\n    }\n    const ext = {\n      kind: extendedExtension.kind,\n      uri: extendedExtension.uri,\n      preferredId: extendedExtension.recvId,\n      preferredEncrypt: extendedExtension.encrypt,\n      direction: extendedExtension.direction\n    };\n    rtpCapabilities.headerExtensions.push(ext);\n  }\n  return rtpCapabilities;\n}\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\n/**\n * Generate RTP parameters of the given kind for sending media.\n * NOTE: mid, encodings and rtcp fields are left empty.\n */\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\n  const rtpParameters = {\n    mid: undefined,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [],\n    rtcp: {}\n  };\n  for (const extendedCodec of extendedRtpCapabilities.codecs) {\n    if (extendedCodec.kind !== kind) continue;\n    const codec = {\n      mimeType: extendedCodec.mimeType,\n      payloadType: extendedCodec.localPayloadType,\n      clockRate: extendedCodec.clockRate,\n      channels: extendedCodec.channels,\n      parameters: extendedCodec.localParameters,\n      rtcpFeedback: extendedCodec.rtcpFeedback\n    };\n    rtpParameters.codecs.push(codec);\n    // Add RTX codec.\n    if (extendedCodec.localRtxPayloadType) {\n      const rtxCodec = {\n        mimeType: `${extendedCodec.kind}/rtx`,\n        payloadType: extendedCodec.localRtxPayloadType,\n        clockRate: extendedCodec.clockRate,\n        parameters: {\n          apt: extendedCodec.localPayloadType\n        },\n        rtcpFeedback: []\n      };\n      rtpParameters.codecs.push(rtxCodec);\n    }\n  }\n  for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n    // Ignore RTP extensions of a different kind and those not valid for sending.\n    if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {\n      continue;\n    }\n    const ext = {\n      uri: extendedExtension.uri,\n      id: extendedExtension.sendId,\n      encrypt: extendedExtension.encrypt,\n      parameters: {}\n    };\n    rtpParameters.headerExtensions.push(ext);\n  }\n  return rtpParameters;\n}\nexports.getSendingRtpParameters = getSendingRtpParameters;\n/**\n * Generate RTP parameters of the given kind suitable for the remote SDP answer.\n */\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\n  const rtpParameters = {\n    mid: undefined,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [],\n    rtcp: {}\n  };\n  for (const extendedCodec of extendedRtpCapabilities.codecs) {\n    if (extendedCodec.kind !== kind) continue;\n    const codec = {\n      mimeType: extendedCodec.mimeType,\n      payloadType: extendedCodec.localPayloadType,\n      clockRate: extendedCodec.clockRate,\n      channels: extendedCodec.channels,\n      parameters: extendedCodec.remoteParameters,\n      rtcpFeedback: extendedCodec.rtcpFeedback\n    };\n    rtpParameters.codecs.push(codec);\n    // Add RTX codec.\n    if (extendedCodec.localRtxPayloadType) {\n      const rtxCodec = {\n        mimeType: `${extendedCodec.kind}/rtx`,\n        payloadType: extendedCodec.localRtxPayloadType,\n        clockRate: extendedCodec.clockRate,\n        parameters: {\n          apt: extendedCodec.localPayloadType\n        },\n        rtcpFeedback: []\n      };\n      rtpParameters.codecs.push(rtxCodec);\n    }\n  }\n  for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n    // Ignore RTP extensions of a different kind and those not valid for sending.\n    if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {\n      continue;\n    }\n    const ext = {\n      uri: extendedExtension.uri,\n      id: extendedExtension.sendId,\n      encrypt: extendedExtension.encrypt,\n      parameters: {}\n    };\n    rtpParameters.headerExtensions.push(ext);\n  }\n  // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.\n  if (rtpParameters.headerExtensions.some(ext => ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01')) {\n    for (const codec of rtpParameters.codecs) {\n      codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(fb => fb.type !== 'goog-remb');\n    }\n  } else if (rtpParameters.headerExtensions.some(ext => ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time')) {\n    for (const codec of rtpParameters.codecs) {\n      codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(fb => fb.type !== 'transport-cc');\n    }\n  } else {\n    for (const codec of rtpParameters.codecs) {\n      codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(fb => fb.type !== 'transport-cc' && fb.type !== 'goog-remb');\n    }\n  }\n  return rtpParameters;\n}\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\n/**\n * Reduce given codecs by returning an array of codecs \"compatible\" with the\n * given capability codec. If no capability codec is given, take the first\n * one(s).\n *\n * Given codecs must be generated by ortc.getSendingRtpParameters() or\n * ortc.getSendingRemoteRtpParameters().\n *\n * The returned array of codecs also include a RTX codec if available.\n */\nfunction reduceCodecs(codecs, capCodec) {\n  const filteredCodecs = [];\n  // If no capability codec is given, take the first one (and RTX).\n  if (!capCodec) {\n    filteredCodecs.push(codecs[0]);\n    if (isRtxCodec(codecs[1])) filteredCodecs.push(codecs[1]);\n  }\n  // Otherwise look for a compatible set of codecs.\n  else {\n    for (let idx = 0; idx < codecs.length; ++idx) {\n      if (matchCodecs(codecs[idx], capCodec)) {\n        filteredCodecs.push(codecs[idx]);\n        if (isRtxCodec(codecs[idx + 1])) filteredCodecs.push(codecs[idx + 1]);\n        break;\n      }\n    }\n    if (filteredCodecs.length === 0) throw new TypeError('no matching codec found');\n  }\n  return filteredCodecs;\n}\nexports.reduceCodecs = reduceCodecs;\n/**\n * Create RTP parameters for a Consumer for the RTP probator.\n */\nfunction generateProbatorRtpParameters(videoRtpParameters) {\n  // Clone given reference video RTP parameters.\n  videoRtpParameters = utils.clone(videoRtpParameters, {});\n  // This may throw.\n  validateRtpParameters(videoRtpParameters);\n  const rtpParameters = {\n    mid: RTP_PROBATOR_MID,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [{\n      ssrc: RTP_PROBATOR_SSRC\n    }],\n    rtcp: {\n      cname: 'probator'\n    }\n  };\n  rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\n  rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\n  rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\n  return rtpParameters;\n}\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\n/**\n * Whether media can be sent based on the given RTP capabilities.\n */\nfunction canSend(kind, extendedRtpCapabilities) {\n  return extendedRtpCapabilities.codecs.some(codec => codec.kind === kind);\n}\nexports.canSend = canSend;\n/**\n * Whether the given RTP parameters can be received with the given RTP\n * capabilities.\n */\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\n  // This may throw.\n  validateRtpParameters(rtpParameters);\n  if (rtpParameters.codecs.length === 0) return false;\n  const firstMediaCodec = rtpParameters.codecs[0];\n  return extendedRtpCapabilities.codecs.some(codec => codec.remotePayloadType === firstMediaCodec.payloadType);\n}\nexports.canReceive = canReceive;\nfunction isRtxCodec(codec) {\n  if (!codec) return false;\n  return /.+\\/rtx$/i.test(codec.mimeType);\n}\nfunction matchCodecs(aCodec, bCodec) {\n  let {\n    strict = false,\n    modify = false\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const aMimeType = aCodec.mimeType.toLowerCase();\n  const bMimeType = bCodec.mimeType.toLowerCase();\n  if (aMimeType !== bMimeType) return false;\n  if (aCodec.clockRate !== bCodec.clockRate) return false;\n  if (aCodec.channels !== bCodec.channels) return false;\n  // Per codec special checks.\n  switch (aMimeType) {\n    case 'video/h264':\n      {\n        if (strict) {\n          const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;\n          const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;\n          if (aPacketizationMode !== bPacketizationMode) return false;\n          if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) return false;\n          let selectedProfileLevelId;\n          try {\n            selectedProfileLevelId = h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);\n          } catch (error) {\n            return false;\n          }\n          if (modify) {\n            if (selectedProfileLevelId) {\n              aCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n              bCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n            } else {\n              delete aCodec.parameters['profile-level-id'];\n              delete bCodec.parameters['profile-level-id'];\n            }\n          }\n        }\n        break;\n      }\n    case 'video/vp9':\n      {\n        if (strict) {\n          const aProfileId = aCodec.parameters['profile-id'] || 0;\n          const bProfileId = bCodec.parameters['profile-id'] || 0;\n          if (aProfileId !== bProfileId) return false;\n        }\n        break;\n      }\n  }\n  return true;\n}\nfunction matchHeaderExtensions(aExt, bExt) {\n  if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) return false;\n  if (aExt.uri !== bExt.uri) return false;\n  return true;\n}\nfunction reduceRtcpFeedback(codecA, codecB) {\n  const reducedRtcpFeedback = [];\n  for (const aFb of codecA.rtcpFeedback || []) {\n    const matchingBFb = (codecB.rtcpFeedback || []).find(bFb => bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter));\n    if (matchingBFb) reducedRtcpFeedback.push(matchingBFb);\n  }\n  return reducedRtcpFeedback;\n}","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","canReceive","canSend","generateProbatorRtpParameters","reduceCodecs","getSendingRemoteRtpParameters","getSendingRtpParameters","getRecvRtpCapabilities","getExtendedRtpCapabilities","validateSctpStreamParameters","validateSctpParameters","validateNumSctpStreams","validateSctpCapabilities","validateRtcpParameters","validateRtpEncodingParameters","validateRtpHeaderExtensionParameters","validateRtpCodecParameters","validateRtpParameters","validateRtpHeaderExtension","validateRtcpFeedback","validateRtpCodecCapability","validateRtpCapabilities","h264","require","utils","RTP_PROBATOR_MID","RTP_PROBATOR_SSRC","RTP_PROBATOR_CODEC_PAYLOAD_TYPE","caps","TypeError","codecs","Array","isArray","codec","headerExtensions","ext","MimeTypeRegex","RegExp","mimeType","mimeTypeMatch","exec","kind","toLowerCase","preferredPayloadType","clockRate","channels","parameters","key","keys","rtcpFeedback","fb","type","parameter","uri","preferredId","preferredEncrypt","direction","params","mid","encodings","encoding","rtcp","payloadType","id","encrypt","ssrc","rid","rtx","dtx","scalabilityMode","cname","reducedSize","numStreams","OS","MIS","port","maxMessageSize","streamId","orderedGiven","ordered","maxPacketLifeTime","maxRetransmits","label","protocol","localCaps","remoteCaps","extendedRtpCapabilities","remoteCodec","isRtxCodec","matchingLocalCodec","find","localCodec","matchCodecs","strict","modify","extendedCodec","localPayloadType","localRtxPayloadType","remotePayloadType","remoteRtxPayloadType","localParameters","remoteParameters","reduceRtcpFeedback","push","matchingLocalRtxCodec","apt","matchingRemoteRtxCodec","remoteExt","matchingLocalExt","localExt","matchHeaderExtensions","extendedExt","sendId","recvId","rtpCapabilities","rtxCodec","extendedExtension","rtpParameters","some","filter","capCodec","filteredCodecs","idx","length","videoRtpParameters","clone","firstMediaCodec","test","aCodec","bCodec","aMimeType","bMimeType","aPacketizationMode","bPacketizationMode","isSameProfile","selectedProfileLevelId","generateProfileLevelIdForAnswer","error","aProfileId","bProfileId","aExt","bExt","codecA","codecB","reducedRtcpFeedback","aFb","matchingBFb","bFb"],"sources":["/Users/user/Desktop/solana-hack-1/client/node_modules/mediasoup-client/lib/ortc.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;\nconst h264 = __importStar(require(\"h264-profile-level-id\"));\nconst utils = __importStar(require(\"./utils\"));\nconst RTP_PROBATOR_MID = 'probator';\nconst RTP_PROBATOR_SSRC = 1234;\nconst RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\n/**\n * Validates RtpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCapabilities(caps) {\n    if (typeof caps !== 'object')\n        throw new TypeError('caps is not an object');\n    // codecs is optional. If unset, fill with an empty array.\n    if (caps.codecs && !Array.isArray(caps.codecs))\n        throw new TypeError('caps.codecs is not an array');\n    else if (!caps.codecs)\n        caps.codecs = [];\n    for (const codec of caps.codecs) {\n        validateRtpCodecCapability(codec);\n    }\n    // headerExtensions is optional. If unset, fill with an empty array.\n    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions))\n        throw new TypeError('caps.headerExtensions is not an array');\n    else if (!caps.headerExtensions)\n        caps.headerExtensions = [];\n    for (const ext of caps.headerExtensions) {\n        validateRtpHeaderExtension(ext);\n    }\n}\nexports.validateRtpCapabilities = validateRtpCapabilities;\n/**\n * Validates RtpCodecCapability. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecCapability(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    if (typeof codec !== 'object')\n        throw new TypeError('codec is not an object');\n    // mimeType is mandatory.\n    if (!codec.mimeType || typeof codec.mimeType !== 'string')\n        throw new TypeError('missing codec.mimeType');\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch)\n        throw new TypeError('invalid codec.mimeType');\n    // Just override kind with media component of mimeType.\n    codec.kind = mimeTypeMatch[1].toLowerCase();\n    // preferredPayloadType is optional.\n    if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number')\n        throw new TypeError('invalid codec.preferredPayloadType');\n    // clockRate is mandatory.\n    if (typeof codec.clockRate !== 'number')\n        throw new TypeError('missing codec.clockRate');\n    // channels is optional. If unset, set it to 1 (just if audio).\n    if (codec.kind === 'audio') {\n        if (typeof codec.channels !== 'number')\n            codec.channels = 1;\n    }\n    else {\n        delete codec.channels;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!codec.parameters || typeof codec.parameters !== 'object')\n        codec.parameters = {};\n    for (const key of Object.keys(codec.parameters)) {\n        let value = codec.parameters[key];\n        if (value === undefined) {\n            codec.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n        }\n        // Specific parameters validation.\n        if (key === 'apt') {\n            if (typeof value !== 'number')\n                throw new TypeError('invalid codec apt parameter');\n        }\n    }\n    // rtcpFeedback is optional. If unset, set it to an empty array.\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))\n        codec.rtcpFeedback = [];\n    for (const fb of codec.rtcpFeedback) {\n        validateRtcpFeedback(fb);\n    }\n}\nexports.validateRtpCodecCapability = validateRtpCodecCapability;\n/**\n * Validates RtcpFeedback. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpFeedback(fb) {\n    if (typeof fb !== 'object')\n        throw new TypeError('fb is not an object');\n    // type is mandatory.\n    if (!fb.type || typeof fb.type !== 'string')\n        throw new TypeError('missing fb.type');\n    // parameter is optional. If unset set it to an empty string.\n    if (!fb.parameter || typeof fb.parameter !== 'string')\n        fb.parameter = '';\n}\nexports.validateRtcpFeedback = validateRtcpFeedback;\n/**\n * Validates RtpHeaderExtension. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtension(ext) {\n    if (typeof ext !== 'object')\n        throw new TypeError('ext is not an object');\n    // kind is mandatory.\n    if (ext.kind !== 'audio' && ext.kind !== 'video')\n        throw new TypeError('invalid ext.kind');\n    // uri is mandatory.\n    if (!ext.uri || typeof ext.uri !== 'string')\n        throw new TypeError('missing ext.uri');\n    // preferredId is mandatory.\n    if (typeof ext.preferredId !== 'number')\n        throw new TypeError('missing ext.preferredId');\n    // preferredEncrypt is optional. If unset set it to false.\n    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean')\n        throw new TypeError('invalid ext.preferredEncrypt');\n    else if (!ext.preferredEncrypt)\n        ext.preferredEncrypt = false;\n    // direction is optional. If unset set it to sendrecv.\n    if (ext.direction && typeof ext.direction !== 'string')\n        throw new TypeError('invalid ext.direction');\n    else if (!ext.direction)\n        ext.direction = 'sendrecv';\n}\nexports.validateRtpHeaderExtension = validateRtpHeaderExtension;\n/**\n * Validates RtpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpParameters(params) {\n    if (typeof params !== 'object')\n        throw new TypeError('params is not an object');\n    // mid is optional.\n    if (params.mid && typeof params.mid !== 'string')\n        throw new TypeError('params.mid is not a string');\n    // codecs is mandatory.\n    if (!Array.isArray(params.codecs))\n        throw new TypeError('missing params.codecs');\n    for (const codec of params.codecs) {\n        validateRtpCodecParameters(codec);\n    }\n    // headerExtensions is optional. If unset, fill with an empty array.\n    if (params.headerExtensions && !Array.isArray(params.headerExtensions))\n        throw new TypeError('params.headerExtensions is not an array');\n    else if (!params.headerExtensions)\n        params.headerExtensions = [];\n    for (const ext of params.headerExtensions) {\n        validateRtpHeaderExtensionParameters(ext);\n    }\n    // encodings is optional. If unset, fill with an empty array.\n    if (params.encodings && !Array.isArray(params.encodings))\n        throw new TypeError('params.encodings is not an array');\n    else if (!params.encodings)\n        params.encodings = [];\n    for (const encoding of params.encodings) {\n        validateRtpEncodingParameters(encoding);\n    }\n    // rtcp is optional. If unset, fill with an empty object.\n    if (params.rtcp && typeof params.rtcp !== 'object')\n        throw new TypeError('params.rtcp is not an object');\n    else if (!params.rtcp)\n        params.rtcp = {};\n    validateRtcpParameters(params.rtcp);\n}\nexports.validateRtpParameters = validateRtpParameters;\n/**\n * Validates RtpCodecParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecParameters(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    if (typeof codec !== 'object')\n        throw new TypeError('codec is not an object');\n    // mimeType is mandatory.\n    if (!codec.mimeType || typeof codec.mimeType !== 'string')\n        throw new TypeError('missing codec.mimeType');\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch)\n        throw new TypeError('invalid codec.mimeType');\n    // payloadType is mandatory.\n    if (typeof codec.payloadType !== 'number')\n        throw new TypeError('missing codec.payloadType');\n    // clockRate is mandatory.\n    if (typeof codec.clockRate !== 'number')\n        throw new TypeError('missing codec.clockRate');\n    const kind = mimeTypeMatch[1].toLowerCase();\n    // channels is optional. If unset, set it to 1 (just if audio).\n    if (kind === 'audio') {\n        if (typeof codec.channels !== 'number')\n            codec.channels = 1;\n    }\n    else {\n        delete codec.channels;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!codec.parameters || typeof codec.parameters !== 'object')\n        codec.parameters = {};\n    for (const key of Object.keys(codec.parameters)) {\n        let value = codec.parameters[key];\n        if (value === undefined) {\n            codec.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n        }\n        // Specific parameters validation.\n        if (key === 'apt') {\n            if (typeof value !== 'number')\n                throw new TypeError('invalid codec apt parameter');\n        }\n    }\n    // rtcpFeedback is optional. If unset, set it to an empty array.\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))\n        codec.rtcpFeedback = [];\n    for (const fb of codec.rtcpFeedback) {\n        validateRtcpFeedback(fb);\n    }\n}\nexports.validateRtpCodecParameters = validateRtpCodecParameters;\n/**\n * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtensionParameters(ext) {\n    if (typeof ext !== 'object')\n        throw new TypeError('ext is not an object');\n    // uri is mandatory.\n    if (!ext.uri || typeof ext.uri !== 'string')\n        throw new TypeError('missing ext.uri');\n    // id is mandatory.\n    if (typeof ext.id !== 'number')\n        throw new TypeError('missing ext.id');\n    // encrypt is optional. If unset set it to false.\n    if (ext.encrypt && typeof ext.encrypt !== 'boolean')\n        throw new TypeError('invalid ext.encrypt');\n    else if (!ext.encrypt)\n        ext.encrypt = false;\n    // parameters is optional. If unset, set it to an empty object.\n    if (!ext.parameters || typeof ext.parameters !== 'object')\n        ext.parameters = {};\n    for (const key of Object.keys(ext.parameters)) {\n        let value = ext.parameters[key];\n        if (value === undefined) {\n            ext.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number')\n            throw new TypeError('invalid header extension parameter');\n    }\n}\nexports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;\n/**\n * Validates RtpEncodingParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpEncodingParameters(encoding) {\n    if (typeof encoding !== 'object')\n        throw new TypeError('encoding is not an object');\n    // ssrc is optional.\n    if (encoding.ssrc && typeof encoding.ssrc !== 'number')\n        throw new TypeError('invalid encoding.ssrc');\n    // rid is optional.\n    if (encoding.rid && typeof encoding.rid !== 'string')\n        throw new TypeError('invalid encoding.rid');\n    // rtx is optional.\n    if (encoding.rtx && typeof encoding.rtx !== 'object') {\n        throw new TypeError('invalid encoding.rtx');\n    }\n    else if (encoding.rtx) {\n        // RTX ssrc is mandatory if rtx is present.\n        if (typeof encoding.rtx.ssrc !== 'number')\n            throw new TypeError('missing encoding.rtx.ssrc');\n    }\n    // dtx is optional. If unset set it to false.\n    if (!encoding.dtx || typeof encoding.dtx !== 'boolean')\n        encoding.dtx = false;\n    // scalabilityMode is optional.\n    if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string')\n        throw new TypeError('invalid encoding.scalabilityMode');\n}\nexports.validateRtpEncodingParameters = validateRtpEncodingParameters;\n/**\n * Validates RtcpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpParameters(rtcp) {\n    if (typeof rtcp !== 'object')\n        throw new TypeError('rtcp is not an object');\n    // cname is optional.\n    if (rtcp.cname && typeof rtcp.cname !== 'string')\n        throw new TypeError('invalid rtcp.cname');\n    // reducedSize is optional. If unset set it to true.\n    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean')\n        rtcp.reducedSize = true;\n}\nexports.validateRtcpParameters = validateRtcpParameters;\n/**\n * Validates SctpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpCapabilities(caps) {\n    if (typeof caps !== 'object')\n        throw new TypeError('caps is not an object');\n    // numStreams is mandatory.\n    if (!caps.numStreams || typeof caps.numStreams !== 'object')\n        throw new TypeError('missing caps.numStreams');\n    validateNumSctpStreams(caps.numStreams);\n}\nexports.validateSctpCapabilities = validateSctpCapabilities;\n/**\n * Validates NumSctpStreams. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateNumSctpStreams(numStreams) {\n    if (typeof numStreams !== 'object')\n        throw new TypeError('numStreams is not an object');\n    // OS is mandatory.\n    if (typeof numStreams.OS !== 'number')\n        throw new TypeError('missing numStreams.OS');\n    // MIS is mandatory.\n    if (typeof numStreams.MIS !== 'number')\n        throw new TypeError('missing numStreams.MIS');\n}\nexports.validateNumSctpStreams = validateNumSctpStreams;\n/**\n * Validates SctpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpParameters(params) {\n    if (typeof params !== 'object')\n        throw new TypeError('params is not an object');\n    // port is mandatory.\n    if (typeof params.port !== 'number')\n        throw new TypeError('missing params.port');\n    // OS is mandatory.\n    if (typeof params.OS !== 'number')\n        throw new TypeError('missing params.OS');\n    // MIS is mandatory.\n    if (typeof params.MIS !== 'number')\n        throw new TypeError('missing params.MIS');\n    // maxMessageSize is mandatory.\n    if (typeof params.maxMessageSize !== 'number')\n        throw new TypeError('missing params.maxMessageSize');\n}\nexports.validateSctpParameters = validateSctpParameters;\n/**\n * Validates SctpStreamParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpStreamParameters(params) {\n    if (typeof params !== 'object')\n        throw new TypeError('params is not an object');\n    // streamId is mandatory.\n    if (typeof params.streamId !== 'number')\n        throw new TypeError('missing params.streamId');\n    // ordered is optional.\n    let orderedGiven = false;\n    if (typeof params.ordered === 'boolean')\n        orderedGiven = true;\n    else\n        params.ordered = true;\n    // maxPacketLifeTime is optional.\n    if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number')\n        throw new TypeError('invalid params.maxPacketLifeTime');\n    // maxRetransmits is optional.\n    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number')\n        throw new TypeError('invalid params.maxRetransmits');\n    if (params.maxPacketLifeTime && params.maxRetransmits)\n        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\n    if (orderedGiven &&\n        params.ordered &&\n        (params.maxPacketLifeTime || params.maxRetransmits)) {\n        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\n    }\n    else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {\n        params.ordered = false;\n    }\n    // label is optional.\n    if (params.label && typeof params.label !== 'string')\n        throw new TypeError('invalid params.label');\n    // protocol is optional.\n    if (params.protocol && typeof params.protocol !== 'string')\n        throw new TypeError('invalid params.protocol');\n}\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\n/**\n * Generate extended RTP capabilities for sending and receiving.\n */\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps) {\n    const extendedRtpCapabilities = {\n        codecs: [],\n        headerExtensions: []\n    };\n    // Match media codecs and keep the order preferred by remoteCaps.\n    for (const remoteCodec of remoteCaps.codecs || []) {\n        if (isRtxCodec(remoteCodec))\n            continue;\n        const matchingLocalCodec = (localCaps.codecs || [])\n            .find((localCodec) => (matchCodecs(localCodec, remoteCodec, { strict: true, modify: true })));\n        if (!matchingLocalCodec)\n            continue;\n        const extendedCodec = {\n            mimeType: matchingLocalCodec.mimeType,\n            kind: matchingLocalCodec.kind,\n            clockRate: matchingLocalCodec.clockRate,\n            channels: matchingLocalCodec.channels,\n            localPayloadType: matchingLocalCodec.preferredPayloadType,\n            localRtxPayloadType: undefined,\n            remotePayloadType: remoteCodec.preferredPayloadType,\n            remoteRtxPayloadType: undefined,\n            localParameters: matchingLocalCodec.parameters,\n            remoteParameters: remoteCodec.parameters,\n            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)\n        };\n        extendedRtpCapabilities.codecs.push(extendedCodec);\n    }\n    // Match RTX codecs.\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        const matchingLocalRtxCodec = localCaps.codecs\n            .find((localCodec) => (isRtxCodec(localCodec) &&\n            localCodec.parameters.apt === extendedCodec.localPayloadType));\n        const matchingRemoteRtxCodec = remoteCaps.codecs\n            .find((remoteCodec) => (isRtxCodec(remoteCodec) &&\n            remoteCodec.parameters.apt === extendedCodec.remotePayloadType));\n        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\n            extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;\n            extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;\n        }\n    }\n    // Match header extensions.\n    for (const remoteExt of remoteCaps.headerExtensions) {\n        const matchingLocalExt = localCaps.headerExtensions\n            .find((localExt) => (matchHeaderExtensions(localExt, remoteExt)));\n        if (!matchingLocalExt)\n            continue;\n        const extendedExt = {\n            kind: remoteExt.kind,\n            uri: remoteExt.uri,\n            sendId: matchingLocalExt.preferredId,\n            recvId: remoteExt.preferredId,\n            encrypt: matchingLocalExt.preferredEncrypt,\n            direction: 'sendrecv'\n        };\n        switch (remoteExt.direction) {\n            case 'sendrecv':\n                extendedExt.direction = 'sendrecv';\n                break;\n            case 'recvonly':\n                extendedExt.direction = 'sendonly';\n                break;\n            case 'sendonly':\n                extendedExt.direction = 'recvonly';\n                break;\n            case 'inactive':\n                extendedExt.direction = 'inactive';\n                break;\n        }\n        extendedRtpCapabilities.headerExtensions.push(extendedExt);\n    }\n    return extendedRtpCapabilities;\n}\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\n/**\n * Generate RTP capabilities for receiving media based on the given extended\n * RTP capabilities.\n */\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\n    const rtpCapabilities = {\n        codecs: [],\n        headerExtensions: []\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            kind: extendedCodec.kind,\n            preferredPayloadType: extendedCodec.remotePayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.localParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback\n        };\n        rtpCapabilities.codecs.push(codec);\n        // Add RTX codec.\n        if (!extendedCodec.remoteRtxPayloadType)\n            continue;\n        const rtxCodec = {\n            mimeType: `${extendedCodec.kind}/rtx`,\n            kind: extendedCodec.kind,\n            preferredPayloadType: extendedCodec.remoteRtxPayloadType,\n            clockRate: extendedCodec.clockRate,\n            parameters: {\n                apt: extendedCodec.remotePayloadType\n            },\n            rtcpFeedback: []\n        };\n        rtpCapabilities.codecs.push(rtxCodec);\n        // TODO: In the future, we need to add FEC, CN, etc, codecs.\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions not valid for receiving.\n        if (extendedExtension.direction !== 'sendrecv' &&\n            extendedExtension.direction !== 'recvonly') {\n            continue;\n        }\n        const ext = {\n            kind: extendedExtension.kind,\n            uri: extendedExtension.uri,\n            preferredId: extendedExtension.recvId,\n            preferredEncrypt: extendedExtension.encrypt,\n            direction: extendedExtension.direction\n        };\n        rtpCapabilities.headerExtensions.push(ext);\n    }\n    return rtpCapabilities;\n}\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\n/**\n * Generate RTP parameters of the given kind for sending media.\n * NOTE: mid, encodings and rtcp fields are left empty.\n */\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\n    const rtpParameters = {\n        mid: undefined,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [],\n        rtcp: {}\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        if (extendedCodec.kind !== kind)\n            continue;\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            payloadType: extendedCodec.localPayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.localParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback\n        };\n        rtpParameters.codecs.push(codec);\n        // Add RTX codec.\n        if (extendedCodec.localRtxPayloadType) {\n            const rtxCodec = {\n                mimeType: `${extendedCodec.kind}/rtx`,\n                payloadType: extendedCodec.localRtxPayloadType,\n                clockRate: extendedCodec.clockRate,\n                parameters: {\n                    apt: extendedCodec.localPayloadType\n                },\n                rtcpFeedback: []\n            };\n            rtpParameters.codecs.push(rtxCodec);\n        }\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions of a different kind and those not valid for sending.\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\n            (extendedExtension.direction !== 'sendrecv' &&\n                extendedExtension.direction !== 'sendonly')) {\n            continue;\n        }\n        const ext = {\n            uri: extendedExtension.uri,\n            id: extendedExtension.sendId,\n            encrypt: extendedExtension.encrypt,\n            parameters: {}\n        };\n        rtpParameters.headerExtensions.push(ext);\n    }\n    return rtpParameters;\n}\nexports.getSendingRtpParameters = getSendingRtpParameters;\n/**\n * Generate RTP parameters of the given kind suitable for the remote SDP answer.\n */\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\n    const rtpParameters = {\n        mid: undefined,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [],\n        rtcp: {}\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        if (extendedCodec.kind !== kind)\n            continue;\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            payloadType: extendedCodec.localPayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.remoteParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback\n        };\n        rtpParameters.codecs.push(codec);\n        // Add RTX codec.\n        if (extendedCodec.localRtxPayloadType) {\n            const rtxCodec = {\n                mimeType: `${extendedCodec.kind}/rtx`,\n                payloadType: extendedCodec.localRtxPayloadType,\n                clockRate: extendedCodec.clockRate,\n                parameters: {\n                    apt: extendedCodec.localPayloadType\n                },\n                rtcpFeedback: []\n            };\n            rtpParameters.codecs.push(rtxCodec);\n        }\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions of a different kind and those not valid for sending.\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\n            (extendedExtension.direction !== 'sendrecv' &&\n                extendedExtension.direction !== 'sendonly')) {\n            continue;\n        }\n        const ext = {\n            uri: extendedExtension.uri,\n            id: extendedExtension.sendId,\n            encrypt: extendedExtension.encrypt,\n            parameters: {}\n        };\n        rtpParameters.headerExtensions.push(ext);\n    }\n    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.\n    if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01'))) {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\n                .filter((fb) => fb.type !== 'goog-remb');\n        }\n    }\n    else if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time'))) {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\n                .filter((fb) => fb.type !== 'transport-cc');\n        }\n    }\n    else {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\n                .filter((fb) => (fb.type !== 'transport-cc' &&\n                fb.type !== 'goog-remb'));\n        }\n    }\n    return rtpParameters;\n}\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\n/**\n * Reduce given codecs by returning an array of codecs \"compatible\" with the\n * given capability codec. If no capability codec is given, take the first\n * one(s).\n *\n * Given codecs must be generated by ortc.getSendingRtpParameters() or\n * ortc.getSendingRemoteRtpParameters().\n *\n * The returned array of codecs also include a RTX codec if available.\n */\nfunction reduceCodecs(codecs, capCodec) {\n    const filteredCodecs = [];\n    // If no capability codec is given, take the first one (and RTX).\n    if (!capCodec) {\n        filteredCodecs.push(codecs[0]);\n        if (isRtxCodec(codecs[1]))\n            filteredCodecs.push(codecs[1]);\n    }\n    // Otherwise look for a compatible set of codecs.\n    else {\n        for (let idx = 0; idx < codecs.length; ++idx) {\n            if (matchCodecs(codecs[idx], capCodec)) {\n                filteredCodecs.push(codecs[idx]);\n                if (isRtxCodec(codecs[idx + 1]))\n                    filteredCodecs.push(codecs[idx + 1]);\n                break;\n            }\n        }\n        if (filteredCodecs.length === 0)\n            throw new TypeError('no matching codec found');\n    }\n    return filteredCodecs;\n}\nexports.reduceCodecs = reduceCodecs;\n/**\n * Create RTP parameters for a Consumer for the RTP probator.\n */\nfunction generateProbatorRtpParameters(videoRtpParameters) {\n    // Clone given reference video RTP parameters.\n    videoRtpParameters = utils.clone(videoRtpParameters, {});\n    // This may throw.\n    validateRtpParameters(videoRtpParameters);\n    const rtpParameters = {\n        mid: RTP_PROBATOR_MID,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],\n        rtcp: { cname: 'probator' }\n    };\n    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\n    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\n    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\n    return rtpParameters;\n}\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\n/**\n * Whether media can be sent based on the given RTP capabilities.\n */\nfunction canSend(kind, extendedRtpCapabilities) {\n    return extendedRtpCapabilities.codecs.\n        some((codec) => codec.kind === kind);\n}\nexports.canSend = canSend;\n/**\n * Whether the given RTP parameters can be received with the given RTP\n * capabilities.\n */\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\n    // This may throw.\n    validateRtpParameters(rtpParameters);\n    if (rtpParameters.codecs.length === 0)\n        return false;\n    const firstMediaCodec = rtpParameters.codecs[0];\n    return extendedRtpCapabilities.codecs\n        .some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);\n}\nexports.canReceive = canReceive;\nfunction isRtxCodec(codec) {\n    if (!codec)\n        return false;\n    return /.+\\/rtx$/i.test(codec.mimeType);\n}\nfunction matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {\n    const aMimeType = aCodec.mimeType.toLowerCase();\n    const bMimeType = bCodec.mimeType.toLowerCase();\n    if (aMimeType !== bMimeType)\n        return false;\n    if (aCodec.clockRate !== bCodec.clockRate)\n        return false;\n    if (aCodec.channels !== bCodec.channels)\n        return false;\n    // Per codec special checks.\n    switch (aMimeType) {\n        case 'video/h264':\n            {\n                if (strict) {\n                    const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;\n                    const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;\n                    if (aPacketizationMode !== bPacketizationMode)\n                        return false;\n                    if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters))\n                        return false;\n                    let selectedProfileLevelId;\n                    try {\n                        selectedProfileLevelId =\n                            h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);\n                    }\n                    catch (error) {\n                        return false;\n                    }\n                    if (modify) {\n                        if (selectedProfileLevelId) {\n                            aCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n                            bCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n                        }\n                        else {\n                            delete aCodec.parameters['profile-level-id'];\n                            delete bCodec.parameters['profile-level-id'];\n                        }\n                    }\n                }\n                break;\n            }\n        case 'video/vp9':\n            {\n                if (strict) {\n                    const aProfileId = aCodec.parameters['profile-id'] || 0;\n                    const bProfileId = bCodec.parameters['profile-id'] || 0;\n                    if (aProfileId !== bProfileId)\n                        return false;\n                }\n                break;\n            }\n    }\n    return true;\n}\nfunction matchHeaderExtensions(aExt, bExt) {\n    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind)\n        return false;\n    if (aExt.uri !== bExt.uri)\n        return false;\n    return true;\n}\nfunction reduceRtcpFeedback(codecA, codecB) {\n    const reducedRtcpFeedback = [];\n    for (const aFb of codecA.rtcpFeedback || []) {\n        const matchingBFb = (codecB.rtcpFeedback || [])\n            .find((bFb) => (bFb.type === aFb.type &&\n            (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter))));\n        if (matchingBFb)\n            reducedRtcpFeedback.push(matchingBFb);\n    }\n    return reducedRtcpFeedback;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}