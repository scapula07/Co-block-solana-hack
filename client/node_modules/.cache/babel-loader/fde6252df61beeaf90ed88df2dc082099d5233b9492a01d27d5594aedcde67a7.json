{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Safari11 = void 0;\nconst sdpTransform = __importStar(require(\"sdp-transform\"));\nconst Logger_1 = require(\"../Logger\");\nconst utils = __importStar(require(\"../utils\"));\nconst ortc = __importStar(require(\"../ortc\"));\nconst sdpCommonUtils = __importStar(require(\"./sdp/commonUtils\"));\nconst sdpPlanBUtils = __importStar(require(\"./sdp/planBUtils\"));\nconst HandlerInterface_1 = require(\"./HandlerInterface\");\nconst RemoteSdp_1 = require(\"./sdp/RemoteSdp\");\nconst logger = new Logger_1.Logger('Safari11');\nconst SCTP_NUM_STREAMS = {\n  OS: 1024,\n  MIS: 1024\n};\nclass Safari11 extends HandlerInterface_1.HandlerInterface {\n  /**\n   * Creates a factory function.\n   */\n  static createFactory() {\n    return () => new Safari11();\n  }\n  constructor() {\n    super();\n    // Local stream for sending.\n    this._sendStream = new MediaStream();\n    // Map of RTCRtpSender indexed by localId.\n    this._mapSendLocalIdRtpSender = new Map();\n    // Next sending localId.\n    this._nextSendLocalId = 0;\n    // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n    // Value is an Object with mid, rtpParameters and rtpReceiver.\n    this._mapRecvLocalIdInfo = new Map();\n    // Whether a DataChannel m=application section has been created.\n    this._hasDataChannelMediaSection = false;\n    // Sending DataChannel id value counter. Incremented for each new DataChannel.\n    this._nextSendSctpStreamId = 0;\n    // Got transport local and remote parameters.\n    this._transportReady = false;\n  }\n  get name() {\n    return 'Safari11';\n  }\n  close() {\n    logger.debug('close()');\n    // Close RTCPeerConnection.\n    if (this._pc) {\n      try {\n        this._pc.close();\n      } catch (error) {}\n    }\n    this.emit('@close');\n  }\n  async getNativeRtpCapabilities() {\n    logger.debug('getNativeRtpCapabilities()');\n    const pc = new RTCPeerConnection({\n      iceServers: [],\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'max-bundle',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'plan-b'\n    });\n    try {\n      const offer = await pc.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true\n      });\n      try {\n        pc.close();\n      } catch (error) {}\n      const sdpObject = sdpTransform.parse(offer.sdp);\n      const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n        sdpObject\n      });\n      return nativeRtpCapabilities;\n    } catch (error) {\n      try {\n        pc.close();\n      } catch (error2) {}\n      throw error;\n    }\n  }\n  async getNativeSctpCapabilities() {\n    logger.debug('getNativeSctpCapabilities()');\n    return {\n      numStreams: SCTP_NUM_STREAMS\n    };\n  }\n  run(_ref) {\n    let {\n      direction,\n      iceParameters,\n      iceCandidates,\n      dtlsParameters,\n      sctpParameters,\n      iceServers,\n      iceTransportPolicy,\n      additionalSettings,\n      proprietaryConstraints,\n      extendedRtpCapabilities\n    } = _ref;\n    logger.debug('run()');\n    this._direction = direction;\n    this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n      iceParameters,\n      iceCandidates,\n      dtlsParameters,\n      sctpParameters,\n      planB: true\n    });\n    this._sendingRtpParametersByKind = {\n      audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n      video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n    };\n    this._sendingRemoteRtpParametersByKind = {\n      audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n      video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n    };\n    if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n      this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';\n    }\n    this._pc = new RTCPeerConnection({\n      iceServers: iceServers || [],\n      iceTransportPolicy: iceTransportPolicy || 'all',\n      bundlePolicy: 'max-bundle',\n      rtcpMuxPolicy: 'require',\n      ...additionalSettings\n    }, proprietaryConstraints);\n    if (this._pc.connectionState) {\n      this._pc.addEventListener('connectionstatechange', () => {\n        this.emit('@connectionstatechange', this._pc.connectionState);\n      });\n    } else {\n      this._pc.addEventListener('iceconnectionstatechange', () => {\n        logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n        switch (this._pc.iceConnectionState) {\n          case 'checking':\n            this.emit('@connectionstatechange', 'connecting');\n            break;\n          case 'connected':\n          case 'completed':\n            this.emit('@connectionstatechange', 'connected');\n            break;\n          case 'failed':\n            this.emit('@connectionstatechange', 'failed');\n            break;\n          case 'disconnected':\n            this.emit('@connectionstatechange', 'disconnected');\n            break;\n          case 'closed':\n            this.emit('@connectionstatechange', 'closed');\n            break;\n        }\n      });\n    }\n  }\n  async updateIceServers(iceServers) {\n    logger.debug('updateIceServers()');\n    const configuration = this._pc.getConfiguration();\n    configuration.iceServers = iceServers;\n    this._pc.setConfiguration(configuration);\n  }\n  async restartIce(iceParameters) {\n    logger.debug('restartIce()');\n    // Provide the remote SDP handler with new remote ICE parameters.\n    this._remoteSdp.updateIceParameters(iceParameters);\n    if (!this._transportReady) return;\n    if (this._direction === 'send') {\n      const offer = await this._pc.createOffer({\n        iceRestart: true\n      });\n      logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n      await this._pc.setLocalDescription(offer);\n      const answer = {\n        type: 'answer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setRemoteDescription(answer);\n    } else {\n      const offer = {\n        type: 'offer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n      await this._pc.setRemoteDescription(offer);\n      const answer = await this._pc.createAnswer();\n      logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n      await this._pc.setLocalDescription(answer);\n    }\n  }\n  async getTransportStats() {\n    return this._pc.getStats();\n  }\n  async send(_ref2) {\n    let {\n      track,\n      encodings,\n      codecOptions,\n      codec\n    } = _ref2;\n    var _a;\n    this.assertSendDirection();\n    logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n    if (codec) {\n      logger.warn('send() | codec selection is not available in %s handler', this.name);\n    }\n    this._sendStream.addTrack(track);\n    this._pc.addTrack(track, this._sendStream);\n    let offer = await this._pc.createOffer();\n    let localSdpObject = sdpTransform.parse(offer.sdp);\n    let offerMediaObject;\n    const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});\n    sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);\n    const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});\n    sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n    if (!this._transportReady) {\n      await this.setupTransport({\n        localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',\n        localSdpObject\n      });\n    }\n    if (track.kind === 'video' && encodings && encodings.length > 1) {\n      logger.debug('send() | enabling simulcast');\n      localSdpObject = sdpTransform.parse(offer.sdp);\n      offerMediaObject = localSdpObject.media.find(m => m.type === 'video');\n      sdpPlanBUtils.addLegacySimulcast({\n        offerMediaObject,\n        track,\n        numStreams: encodings.length\n      });\n      offer = {\n        type: 'offer',\n        sdp: sdpTransform.write(localSdpObject)\n      };\n    }\n    logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n    await this._pc.setLocalDescription(offer);\n    localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n    offerMediaObject = localSdpObject.media.find(m => m.type === track.kind);\n    // Set RTCP CNAME.\n    sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n      offerMediaObject\n    });\n    // Set RTP encodings.\n    sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({\n      offerMediaObject,\n      track\n    });\n    // Complete encodings with given values.\n    if (encodings) {\n      for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n        if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n      }\n    }\n    // If VP8 and there is effective simulcast, add scalabilityMode to each\n    // encoding.\n    if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n      for (const encoding of sendingRtpParameters.encodings) {\n        encoding.scalabilityMode = 'S1T3';\n      }\n    }\n    this._remoteSdp.send({\n      offerMediaObject,\n      offerRtpParameters: sendingRtpParameters,\n      answerRtpParameters: sendingRemoteRtpParameters,\n      codecOptions\n    });\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n    const localId = String(this._nextSendLocalId);\n    this._nextSendLocalId++;\n    const rtpSender = this._pc.getSenders().find(s => s.track === track);\n    // Insert into the map.\n    this._mapSendLocalIdRtpSender.set(localId, rtpSender);\n    return {\n      localId: localId,\n      rtpParameters: sendingRtpParameters,\n      rtpSender\n    };\n  }\n  async stopSending(localId) {\n    this.assertSendDirection();\n    const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n    if (!rtpSender) throw new Error('associated RTCRtpSender not found');\n    if (rtpSender.track) this._sendStream.removeTrack(rtpSender.track);\n    this._mapSendLocalIdRtpSender.delete(localId);\n    const offer = await this._pc.createOffer();\n    logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n    try {\n      await this._pc.setLocalDescription(offer);\n    } catch (error) {\n      // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n      // \"Failed to create channels\". If so, ignore it.\n      if (this._sendStream.getTracks().length === 0) {\n        logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n        return;\n      }\n      throw error;\n    }\n    if (this._pc.signalingState === 'stable') return;\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async pauseSending(localId) {\n    // Unimplemented.\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async resumeSending(localId) {\n    // Unimplemented.\n  }\n  async replaceTrack(localId, track) {\n    this.assertSendDirection();\n    if (track) {\n      logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n    } else {\n      logger.debug('replaceTrack() [localId:%s, no track]', localId);\n    }\n    const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n    if (!rtpSender) throw new Error('associated RTCRtpSender not found');\n    const oldTrack = rtpSender.track;\n    await rtpSender.replaceTrack(track);\n    // Remove the old track from the local stream.\n    if (oldTrack) this._sendStream.removeTrack(oldTrack);\n    // Add the new track to the local stream.\n    if (track) this._sendStream.addTrack(track);\n  }\n  async setMaxSpatialLayer(localId, spatialLayer) {\n    this.assertSendDirection();\n    logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n    const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n    if (!rtpSender) throw new Error('associated RTCRtpSender not found');\n    const parameters = rtpSender.getParameters();\n    parameters.encodings.forEach((encoding, idx) => {\n      if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;\n    });\n    await rtpSender.setParameters(parameters);\n  }\n  async setRtpEncodingParameters(localId, params) {\n    this.assertSendDirection();\n    logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n    const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n    if (!rtpSender) throw new Error('associated RTCRtpSender not found');\n    const parameters = rtpSender.getParameters();\n    parameters.encodings.forEach((encoding, idx) => {\n      parameters.encodings[idx] = {\n        ...encoding,\n        ...params\n      };\n    });\n    await rtpSender.setParameters(parameters);\n  }\n  async getSenderStats(localId) {\n    this.assertSendDirection();\n    const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n    if (!rtpSender) throw new Error('associated RTCRtpSender not found');\n    return rtpSender.getStats();\n  }\n  async sendDataChannel(_ref3) {\n    let {\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmits,\n      label,\n      protocol\n    } = _ref3;\n    var _a;\n    this.assertSendDirection();\n    const options = {\n      negotiated: true,\n      id: this._nextSendSctpStreamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmits,\n      protocol\n    };\n    logger.debug('sendDataChannel() [options:%o]', options);\n    const dataChannel = this._pc.createDataChannel(label, options);\n    // Increase next id.\n    this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n    // If this is the first DataChannel we need to create the SDP answer with\n    // m=application section.\n    if (!this._hasDataChannelMediaSection) {\n      const offer = await this._pc.createOffer();\n      const localSdpObject = sdpTransform.parse(offer.sdp);\n      const offerMediaObject = localSdpObject.media.find(m => m.type === 'application');\n      if (!this._transportReady) {\n        await this.setupTransport({\n          localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',\n          localSdpObject\n        });\n      }\n      logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n      await this._pc.setLocalDescription(offer);\n      this._remoteSdp.sendSctpAssociation({\n        offerMediaObject\n      });\n      const answer = {\n        type: 'answer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setRemoteDescription(answer);\n      this._hasDataChannelMediaSection = true;\n    }\n    const sctpStreamParameters = {\n      streamId: options.id,\n      ordered: options.ordered,\n      maxPacketLifeTime: options.maxPacketLifeTime,\n      maxRetransmits: options.maxRetransmits\n    };\n    return {\n      dataChannel,\n      sctpStreamParameters\n    };\n  }\n  async receive(optionsList) {\n    var _a;\n    this.assertRecvDirection();\n    const results = [];\n    for (const options of optionsList) {\n      const {\n        trackId,\n        kind,\n        rtpParameters,\n        streamId\n      } = options;\n      logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n      const mid = kind;\n      this._remoteSdp.receive({\n        mid,\n        kind,\n        offerRtpParameters: rtpParameters,\n        streamId: streamId || rtpParameters.rtcp.cname,\n        trackId\n      });\n    }\n    const offer = {\n      type: 'offer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n    await this._pc.setRemoteDescription(offer);\n    let answer = await this._pc.createAnswer();\n    const localSdpObject = sdpTransform.parse(answer.sdp);\n    for (const options of optionsList) {\n      const {\n        kind,\n        rtpParameters\n      } = options;\n      const mid = kind;\n      const answerMediaObject = localSdpObject.media.find(m => String(m.mid) === mid);\n      // May need to modify codec parameters in the answer based on codec\n      // parameters in the offer.\n      sdpCommonUtils.applyCodecParameters({\n        offerRtpParameters: rtpParameters,\n        answerMediaObject\n      });\n    }\n    answer = {\n      type: 'answer',\n      sdp: sdpTransform.write(localSdpObject)\n    };\n    if (!this._transportReady) {\n      await this.setupTransport({\n        localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',\n        localSdpObject\n      });\n    }\n    logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n    await this._pc.setLocalDescription(answer);\n    for (const options of optionsList) {\n      const {\n        kind,\n        trackId,\n        rtpParameters\n      } = options;\n      const mid = kind;\n      const localId = trackId;\n      const rtpReceiver = this._pc.getReceivers().find(r => r.track && r.track.id === localId);\n      if (!rtpReceiver) throw new Error('new RTCRtpReceiver not');\n      // Insert into the map.\n      this._mapRecvLocalIdInfo.set(localId, {\n        mid,\n        rtpParameters,\n        rtpReceiver\n      });\n      results.push({\n        localId,\n        track: rtpReceiver.track,\n        rtpReceiver\n      });\n    }\n    return results;\n  }\n  async stopReceiving(localIds) {\n    this.assertRecvDirection();\n    for (const localId of localIds) {\n      logger.debug('stopReceiving() [localId:%s]', localId);\n      const {\n        mid,\n        rtpParameters\n      } = this._mapRecvLocalIdInfo.get(localId) || {};\n      // Remove from the map.\n      this._mapRecvLocalIdInfo.delete(localId);\n      this._remoteSdp.planBStopReceiving({\n        mid: mid,\n        offerRtpParameters: rtpParameters\n      });\n    }\n    const offer = {\n      type: 'offer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n    await this._pc.setRemoteDescription(offer);\n    const answer = await this._pc.createAnswer();\n    logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n    await this._pc.setLocalDescription(answer);\n  }\n  async getReceiverStats(localId) {\n    this.assertRecvDirection();\n    const {\n      rtpReceiver\n    } = this._mapRecvLocalIdInfo.get(localId) || {};\n    if (!rtpReceiver) throw new Error('associated RTCRtpReceiver not found');\n    return rtpReceiver.getStats();\n  }\n  async pauseReceiving(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  localIds) {\n    // Unimplemented.\n  }\n  async resumeReceiving(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  localIds) {\n    // Unimplemented.\n  }\n  async receiveDataChannel(_ref4) {\n    let {\n      sctpStreamParameters,\n      label,\n      protocol\n    } = _ref4;\n    var _a;\n    this.assertRecvDirection();\n    const {\n      streamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmits\n    } = sctpStreamParameters;\n    const options = {\n      negotiated: true,\n      id: streamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmits,\n      protocol\n    };\n    logger.debug('receiveDataChannel() [options:%o]', options);\n    const dataChannel = this._pc.createDataChannel(label, options);\n    // If this is the first DataChannel we need to create the SDP offer with\n    // m=application section.\n    if (!this._hasDataChannelMediaSection) {\n      this._remoteSdp.receiveSctpAssociation({\n        oldDataChannelSpec: true\n      });\n      const offer = {\n        type: 'offer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n      await this._pc.setRemoteDescription(offer);\n      const answer = await this._pc.createAnswer();\n      if (!this._transportReady) {\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        await this.setupTransport({\n          localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',\n          localSdpObject\n        });\n      }\n      logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setLocalDescription(answer);\n      this._hasDataChannelMediaSection = true;\n    }\n    return {\n      dataChannel\n    };\n  }\n  async setupTransport(_ref5) {\n    let {\n      localDtlsRole,\n      localSdpObject\n    } = _ref5;\n    if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n    // Get our local DTLS parameters.\n    const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n      sdpObject: localSdpObject\n    });\n    // Set our DTLS role.\n    dtlsParameters.role = localDtlsRole;\n    // Update the remote DTLS role in the SDP.\n    this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n    // Need to tell the remote transport about our parameters.\n    await new Promise((resolve, reject) => {\n      this.safeEmit('@connect', {\n        dtlsParameters\n      }, resolve, reject);\n    });\n    this._transportReady = true;\n  }\n  assertSendDirection() {\n    if (this._direction !== 'send') {\n      throw new Error('method can just be called for handlers with \"send\" direction');\n    }\n  }\n  assertRecvDirection() {\n    if (this._direction !== 'recv') {\n      throw new Error('method can just be called for handlers with \"recv\" direction');\n    }\n  }\n}\nexports.Safari11 = Safari11;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","Safari11","sdpTransform","require","Logger_1","utils","ortc","sdpCommonUtils","sdpPlanBUtils","HandlerInterface_1","RemoteSdp_1","logger","Logger","SCTP_NUM_STREAMS","OS","MIS","HandlerInterface","createFactory","constructor","_sendStream","MediaStream","_mapSendLocalIdRtpSender","Map","_nextSendLocalId","_mapRecvLocalIdInfo","_hasDataChannelMediaSection","_nextSendSctpStreamId","_transportReady","name","close","debug","_pc","error","emit","getNativeRtpCapabilities","pc","RTCPeerConnection","iceServers","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","sdpSemantics","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","sdpObject","parse","sdp","nativeRtpCapabilities","extractRtpCapabilities","error2","getNativeSctpCapabilities","numStreams","run","direction","iceParameters","iceCandidates","dtlsParameters","sctpParameters","additionalSettings","proprietaryConstraints","extendedRtpCapabilities","_direction","_remoteSdp","RemoteSdp","planB","_sendingRtpParametersByKind","audio","getSendingRtpParameters","video","_sendingRemoteRtpParametersByKind","getSendingRemoteRtpParameters","role","_forcedLocalDtlsRole","connectionState","addEventListener","warn","iceConnectionState","updateIceServers","configuration","getConfiguration","setConfiguration","restartIce","updateIceParameters","iceRestart","setLocalDescription","answer","type","getSdp","setRemoteDescription","createAnswer","getTransportStats","getStats","send","track","encodings","codecOptions","codec","_a","assertSendDirection","kind","id","addTrack","localSdpObject","offerMediaObject","sendingRtpParameters","clone","codecs","reduceCodecs","sendingRemoteRtpParameters","setupTransport","localDtlsRole","length","media","find","addLegacySimulcast","write","localDescription","rtcp","cname","getCname","getRtpEncodings","idx","assign","mimeType","toLowerCase","encoding","scalabilityMode","offerRtpParameters","answerRtpParameters","localId","String","rtpSender","getSenders","s","set","rtpParameters","stopSending","Error","removeTrack","delete","getTracks","toString","signalingState","pauseSending","resumeSending","replaceTrack","oldTrack","setMaxSpatialLayer","spatialLayer","parameters","getParameters","forEach","active","setParameters","setRtpEncodingParameters","params","getSenderStats","sendDataChannel","ordered","maxPacketLifeTime","maxRetransmits","label","protocol","options","negotiated","dataChannel","createDataChannel","sendSctpAssociation","sctpStreamParameters","streamId","receive","optionsList","assertRecvDirection","results","trackId","mid","answerMediaObject","applyCodecParameters","rtpReceiver","getReceivers","r","push","stopReceiving","localIds","planBStopReceiving","getReceiverStats","pauseReceiving","resumeReceiving","receiveDataChannel","receiveSctpAssociation","oldDataChannelSpec","extractDtlsParameters","updateDtlsRole","Promise","resolve","reject","safeEmit"],"sources":["/Users/user/Desktop/solana-hack-1/client/node_modules/mediasoup-client/lib/handlers/Safari11.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Safari11 = void 0;\nconst sdpTransform = __importStar(require(\"sdp-transform\"));\nconst Logger_1 = require(\"../Logger\");\nconst utils = __importStar(require(\"../utils\"));\nconst ortc = __importStar(require(\"../ortc\"));\nconst sdpCommonUtils = __importStar(require(\"./sdp/commonUtils\"));\nconst sdpPlanBUtils = __importStar(require(\"./sdp/planBUtils\"));\nconst HandlerInterface_1 = require(\"./HandlerInterface\");\nconst RemoteSdp_1 = require(\"./sdp/RemoteSdp\");\nconst logger = new Logger_1.Logger('Safari11');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Safari11 extends HandlerInterface_1.HandlerInterface {\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Safari11();\n    }\n    constructor() {\n        super();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Map of RTCRtpSender indexed by localId.\n        this._mapSendLocalIdRtpSender = new Map();\n        // Next sending localId.\n        this._nextSendLocalId = 0;\n        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n        // Value is an Object with mid, rtpParameters and rtpReceiver.\n        this._mapRecvLocalIdInfo = new Map();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    get name() {\n        return 'Safari11';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b'\n        });\n        try {\n            const offer = await pc.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true\n            });\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            planB: true\n        });\n        this._sendingRtpParametersByKind =\n            {\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._sendingRemoteRtpParametersByKind =\n            {\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n            };\n        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n            this._forcedLocalDtlsRole = dtlsParameters.role === 'server'\n                ? 'client'\n                : 'server';\n        }\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            ...additionalSettings\n        }, proprietaryConstraints);\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n                switch (this._pc.iceConnectionState) {\n                    case 'checking':\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    case 'connected':\n                    case 'completed':\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    case 'failed':\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    case 'disconnected':\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    case 'closed':\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                }\n            });\n        }\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady)\n            return;\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec }) {\n        var _a;\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (codec) {\n            logger.warn('send() | codec selection is not available in %s handler', this.name);\n        }\n        this._sendStream.addTrack(track);\n        this._pc.addTrack(track, this._sendStream);\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});\n        sendingRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRtpParameters.codecs);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});\n        sendingRemoteRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',\n                localSdpObject\n            });\n        }\n        if (track.kind === 'video' && encodings && encodings.length > 1) {\n            logger.debug('send() | enabling simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');\n            sdpPlanBUtils.addLegacySimulcast({\n                offerMediaObject,\n                track,\n                numStreams: encodings.length\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media\n            .find((m) => m.type === track.kind);\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname =\n            sdpCommonUtils.getCname({ offerMediaObject });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings =\n            sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx])\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n            }\n        }\n        // If VP8 and there is effective simulcast, add scalabilityMode to each\n        // encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'S1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        const rtpSender = this._pc.getSenders()\n            .find((s) => s.track === track);\n        // Insert into the map.\n        this._mapSendLocalIdRtpSender.set(localId, rtpSender);\n        return {\n            localId: localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        if (rtpSender.track)\n            this._sendStream.removeTrack(rtpSender.track);\n        this._mapSendLocalIdRtpSender.delete(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        try {\n            await this._pc.setLocalDescription(offer);\n        }\n        catch (error) {\n            // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n            // \"Failed to create channels\". If so, ignore it.\n            if (this._sendStream.getTracks().length === 0) {\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n                return;\n            }\n            throw error;\n        }\n        if (this._pc.signalingState === 'stable')\n            return;\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async pauseSending(localId) {\n        // Unimplemented.\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async resumeSending(localId) {\n        // Unimplemented.\n    }\n    async replaceTrack(localId, track) {\n        this.assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        const oldTrack = rtpSender.track;\n        await rtpSender.replaceTrack(track);\n        // Remove the old track from the local stream.\n        if (oldTrack)\n            this._sendStream.removeTrack(oldTrack);\n        // Add the new track to the local stream.\n        if (track)\n            this._sendStream.addTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this.assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer)\n                encoding.active = true;\n            else\n                encoding.active = false;\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this.assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        this.assertSendDirection();\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        return rtpSender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {\n        var _a;\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({\n                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',\n                    localSdpObject\n                });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(optionsList) {\n        var _a;\n        this.assertRecvDirection();\n        const results = [];\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters, streamId } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const mid = kind;\n            this._remoteSdp.receive({\n                mid,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId: streamId || rtpParameters.rtcp.cname,\n                trackId\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { kind, rtpParameters } = options;\n            const mid = kind;\n            const answerMediaObject = localSdpObject.media\n                .find((m) => String(m.mid) === mid);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject\n            });\n        }\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',\n                localSdpObject\n            });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { kind, trackId, rtpParameters } = options;\n            const mid = kind;\n            const localId = trackId;\n            const rtpReceiver = this._pc.getReceivers()\n                .find((r) => r.track && r.track.id === localId);\n            if (!rtpReceiver)\n                throw new Error('new RTCRtpReceiver not');\n            // Insert into the map.\n            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters, rtpReceiver });\n            results.push({\n                localId,\n                track: rtpReceiver.track,\n                rtpReceiver\n            });\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\n            // Remove from the map.\n            this._mapRecvLocalIdInfo.delete(localId);\n            this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this.assertRecvDirection();\n        const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};\n        if (!rtpReceiver)\n            throw new Error('associated RTCRtpReceiver not found');\n        return rtpReceiver.getStats();\n    }\n    async pauseReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async resumeReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {\n        var _a;\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({\n                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',\n                    localSdpObject\n                });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject }) {\n        if (!localSdpObject)\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Safari11 = Safari11;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}