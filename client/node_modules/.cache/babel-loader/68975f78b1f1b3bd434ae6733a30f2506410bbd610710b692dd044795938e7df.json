{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoOutput = void 0;\nconst CryptoECKey_1 = require(\"./CryptoECKey\");\nconst CryptoHDKey_1 = require(\"./CryptoHDKey\");\nconst lib_1 = require(\"./lib\");\nconst MultiKey_1 = require(\"./MultiKey\");\nconst RegistryItem_1 = require(\"./RegistryItem\");\nconst RegistryType_1 = require(\"./RegistryType\");\nconst ScriptExpression_1 = require(\"./ScriptExpression\");\nclass CryptoOutput extends RegistryItem_1.RegistryItem {\n  constructor(scriptExpressions, cryptoKey) {\n    super();\n    this.scriptExpressions = scriptExpressions;\n    this.cryptoKey = cryptoKey;\n    this.getRegistryType = () => {\n      return RegistryType_1.RegistryTypes.CRYPTO_OUTPUT;\n    };\n    this.getCryptoKey = () => this.cryptoKey;\n    this.getHDKey = () => {\n      if (this.cryptoKey instanceof CryptoHDKey_1.CryptoHDKey) {\n        return this.cryptoKey;\n      } else {\n        return undefined;\n      }\n    };\n    this.getECKey = () => {\n      if (this.cryptoKey instanceof CryptoECKey_1.CryptoECKey) {\n        return this.cryptoKey;\n      } else {\n        return undefined;\n      }\n    };\n    this.getMultiKey = () => {\n      if (this.cryptoKey instanceof MultiKey_1.MultiKey) {\n        return this.cryptoKey;\n      } else {\n        return undefined;\n      }\n    };\n    this.getScriptExpressions = () => this.scriptExpressions;\n    this._toOutputDescriptor = seIndex => {\n      if (seIndex >= this.scriptExpressions.length) {\n        return this.cryptoKey.getOutputDescriptorContent();\n      } else {\n        return `${this.scriptExpressions[seIndex].getExpression()}(${this._toOutputDescriptor(seIndex + 1)})`;\n      }\n    };\n    this.toString = () => {\n      return this._toOutputDescriptor(0);\n    };\n    this.toDataItem = () => {\n      let dataItem = this.cryptoKey.toDataItem();\n      if (this.cryptoKey instanceof CryptoECKey_1.CryptoECKey || this.cryptoKey instanceof CryptoHDKey_1.CryptoHDKey) {\n        dataItem.setTag(this.cryptoKey.getRegistryType().getTag());\n      }\n      const clonedSe = [...this.scriptExpressions];\n      clonedSe.reverse().forEach(se => {\n        const tagValue = se.getTag();\n        if (dataItem.getTag() === undefined) {\n          dataItem.setTag(tagValue);\n        } else {\n          dataItem = new lib_1.DataItem(dataItem, tagValue);\n        }\n      });\n      return dataItem;\n    };\n  }\n}\nexports.CryptoOutput = CryptoOutput;\nCryptoOutput.fromDataItem = dataItem => {\n  const scriptExpressions = [];\n  let _dataItem = dataItem;\n  while (true) {\n    let _tag = _dataItem.getTag();\n    const se = ScriptExpression_1.ScriptExpression.fromTag(_tag);\n    if (se) {\n      scriptExpressions.push(se);\n      if (_dataItem.getData() instanceof lib_1.DataItem) {\n        _dataItem = _dataItem.getData();\n        _tag = _dataItem.getTag();\n      } else {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n  const seLength = scriptExpressions.length;\n  const isMultiKey = seLength > 0 && (scriptExpressions[seLength - 1].getExpression() === ScriptExpression_1.ScriptExpressions.MULTISIG.getExpression() || scriptExpressions[seLength - 1].getExpression() === ScriptExpression_1.ScriptExpressions.SORTED_MULTISIG.getExpression());\n  if (isMultiKey) {\n    const multiKey = MultiKey_1.MultiKey.fromDataItem(_dataItem);\n    return new CryptoOutput(scriptExpressions, multiKey);\n  }\n  if (_dataItem.getTag() === RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getTag()) {\n    const cryptoHDKey = CryptoHDKey_1.CryptoHDKey.fromDataItem(_dataItem);\n    return new CryptoOutput(scriptExpressions, cryptoHDKey);\n  } else {\n    const cryptoECKey = CryptoECKey_1.CryptoECKey.fromDataItem(_dataItem);\n    return new CryptoOutput(scriptExpressions, cryptoECKey);\n  }\n};\nCryptoOutput.fromCBOR = _cborPayload => {\n  const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoOutput.fromDataItem(dataItem);\n};","map":{"version":3,"mappings":"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","names":["CryptoOutput","RegistryItem_1","constructor","scriptExpressions","cryptoKey","RegistryType_1","CRYPTO_OUTPUT","CryptoHDKey_1","undefined","CryptoECKey_1","MultiKey_1","seIndex","length","getOutputDescriptorContent","getExpression","_toOutputDescriptor","dataItem","toDataItem","setTag","getRegistryType","getTag","clonedSe","reverse","forEach","se","tagValue","lib_1","exports","_dataItem","_tag","ScriptExpression_1","fromTag","push","getData","seLength","isMultiKey","MULTISIG","SORTED_MULTISIG","multiKey","fromDataItem","CRYPTO_HDKEY","cryptoHDKey","cryptoECKey","_cborPayload"],"sources":["/Users/user/Desktop/solana-hack-1/solana-payroll/node_modules/@keystonehq/bc-ur-registry/src/CryptoOutput.ts"],"sourcesContent":["import { CryptoECKey } from './CryptoECKey';\nimport { CryptoHDKey } from './CryptoHDKey';\nimport { decodeToDataItem, DataItem } from './lib';\nimport { MultiKey } from './MultiKey';\nimport { RegistryItem } from './RegistryItem';\nimport { RegistryTypes } from './RegistryType';\nimport { ScriptExpression, ScriptExpressions } from './ScriptExpression';\n\nexport class CryptoOutput extends RegistryItem {\n  public getRegistryType = () => {\n    return RegistryTypes.CRYPTO_OUTPUT;\n  };\n\n  constructor(\n    private scriptExpressions: ScriptExpression[],\n    private cryptoKey: CryptoHDKey | CryptoECKey | MultiKey,\n  ) {\n    super();\n  }\n\n  public getCryptoKey = () => this.cryptoKey;\n  public getHDKey = () => {\n    if (this.cryptoKey instanceof CryptoHDKey) {\n      return this.cryptoKey as CryptoHDKey;\n    } else {\n      return undefined;\n    }\n  };\n  public getECKey = () => {\n    if (this.cryptoKey instanceof CryptoECKey) {\n      return this.cryptoKey as CryptoECKey;\n    } else {\n      return undefined;\n    }\n  };\n\n  public getMultiKey = () => {\n    if (this.cryptoKey instanceof MultiKey) {\n      return this.cryptoKey as MultiKey;\n    } else {\n      return undefined;\n    }\n  };\n\n  public getScriptExpressions = () => this.scriptExpressions;\n\n  private _toOutputDescriptor = (seIndex: number): string => {\n    if (seIndex >= this.scriptExpressions.length) {\n      return this.cryptoKey.getOutputDescriptorContent();\n    } else {\n      return `${this.scriptExpressions[seIndex].getExpression()}(${this._toOutputDescriptor(seIndex + 1)})`;\n    }\n  };\n\n  public override toString = () => {\n    return this._toOutputDescriptor(0);\n  };\n\n  toDataItem = () => {\n    let dataItem = this.cryptoKey.toDataItem();\n    if (\n      this.cryptoKey instanceof CryptoECKey ||\n      this.cryptoKey instanceof CryptoHDKey\n    ) {\n      dataItem.setTag(this.cryptoKey.getRegistryType().getTag());\n    }\n\n    const clonedSe = [...this.scriptExpressions];\n\n    clonedSe.reverse().forEach((se) => {\n      const tagValue = se.getTag();\n      if (dataItem.getTag() === undefined) {\n        dataItem.setTag(tagValue);\n      } else {\n        dataItem = new DataItem(dataItem, tagValue);\n      }\n    });\n\n    return dataItem;\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const scriptExpressions: ScriptExpression[] = [];\n    let _dataItem = dataItem;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let _tag = _dataItem.getTag();\n      const se = ScriptExpression.fromTag(_tag as number);\n      if (se) {\n        scriptExpressions.push(se);\n        if (_dataItem.getData() instanceof DataItem) {\n          _dataItem = _dataItem.getData();\n          _tag = _dataItem.getTag();\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    const seLength = scriptExpressions.length;\n    const isMultiKey =\n      seLength > 0 &&\n      (scriptExpressions[seLength - 1].getExpression() ===\n        ScriptExpressions.MULTISIG.getExpression() ||\n        scriptExpressions[seLength - 1].getExpression() ===\n        ScriptExpressions.SORTED_MULTISIG.getExpression());\n    //TODO: judge is multi key by scriptExpressions\n    if (isMultiKey) {\n      const multiKey = MultiKey.fromDataItem(_dataItem);\n      return new CryptoOutput(scriptExpressions, multiKey);\n    }\n\n    if (_dataItem.getTag() === RegistryTypes.CRYPTO_HDKEY.getTag()) {\n      const cryptoHDKey = CryptoHDKey.fromDataItem(_dataItem);\n      return new CryptoOutput(scriptExpressions, cryptoHDKey);\n    } else {\n      const cryptoECKey = CryptoECKey.fromDataItem(_dataItem);\n      return new CryptoOutput(scriptExpressions, cryptoECKey);\n    }\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoOutput.fromDataItem(dataItem);\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}