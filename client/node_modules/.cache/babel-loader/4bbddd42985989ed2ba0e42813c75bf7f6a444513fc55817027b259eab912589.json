{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Transport = void 0;\nconst awaitqueue_1 = require(\"awaitqueue\");\nconst Logger_1 = require(\"./Logger\");\nconst EnhancedEventEmitter_1 = require(\"./EnhancedEventEmitter\");\nconst errors_1 = require(\"./errors\");\nconst utils = __importStar(require(\"./utils\"));\nconst ortc = __importStar(require(\"./ortc\"));\nconst Producer_1 = require(\"./Producer\");\nconst Consumer_1 = require(\"./Consumer\");\nconst DataProducer_1 = require(\"./DataProducer\");\nconst DataConsumer_1 = require(\"./DataConsumer\");\nconst logger = new Logger_1.Logger('Transport');\nclass ConsumerCreationTask {\n  constructor(consumerOptions) {\n    this.consumerOptions = consumerOptions;\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\nclass Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n  constructor(_ref) {\n    let {\n      direction,\n      id,\n      iceParameters,\n      iceCandidates,\n      dtlsParameters,\n      sctpParameters,\n      iceServers,\n      iceTransportPolicy,\n      additionalSettings,\n      proprietaryConstraints,\n      appData,\n      handlerFactory,\n      extendedRtpCapabilities,\n      canProduceByKind\n    } = _ref;\n    super();\n    // Closed flag.\n    this._closed = false;\n    // Transport connection state.\n    this._connectionState = 'new';\n    // Map of Producers indexed by id.\n    this._producers = new Map();\n    // Map of Consumers indexed by id.\n    this._consumers = new Map();\n    // Map of DataProducers indexed by id.\n    this._dataProducers = new Map();\n    // Map of DataConsumers indexed by id.\n    this._dataConsumers = new Map();\n    // Whether the Consumer for RTP probation has been created.\n    this._probatorConsumerCreated = false;\n    // AwaitQueue instance to make async tasks happen sequentially.\n    this._awaitQueue = new awaitqueue_1.AwaitQueue();\n    // Consumer creation tasks awaiting to be processed.\n    this._pendingConsumerTasks = [];\n    // Consumer creation in progress flag.\n    this._consumerCreationInProgress = false;\n    // Consumers pending to be paused.\n    this._pendingPauseConsumers = new Map();\n    // Consumer pause in progress flag.\n    this._consumerPauseInProgress = false;\n    // Consumers pending to be resumed.\n    this._pendingResumeConsumers = new Map();\n    // Consumer resume in progress flag.\n    this._consumerResumeInProgress = false;\n    // Consumers pending to be closed.\n    this._pendingCloseConsumers = new Map();\n    // Consumer close in progress flag.\n    this._consumerCloseInProgress = false;\n    // Observer instance.\n    this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();\n    logger.debug('constructor() [id:%s, direction:%s]', id, direction);\n    this._id = id;\n    this._direction = direction;\n    this._extendedRtpCapabilities = extendedRtpCapabilities;\n    this._canProduceByKind = canProduceByKind;\n    this._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null;\n    // Clone and sanitize additionalSettings.\n    additionalSettings = utils.clone(additionalSettings, {});\n    delete additionalSettings.iceServers;\n    delete additionalSettings.iceTransportPolicy;\n    delete additionalSettings.bundlePolicy;\n    delete additionalSettings.rtcpMuxPolicy;\n    delete additionalSettings.sdpSemantics;\n    this._handler = handlerFactory();\n    this._handler.run({\n      direction,\n      iceParameters,\n      iceCandidates,\n      dtlsParameters,\n      sctpParameters,\n      iceServers,\n      iceTransportPolicy,\n      additionalSettings,\n      proprietaryConstraints,\n      extendedRtpCapabilities\n    });\n    this._appData = appData || {};\n    this.handleHandler();\n  }\n  /**\n   * Transport id.\n   */\n  get id() {\n    return this._id;\n  }\n  /**\n   * Whether the Transport is closed.\n   */\n  get closed() {\n    return this._closed;\n  }\n  /**\n   * Transport direction.\n   */\n  get direction() {\n    return this._direction;\n  }\n  /**\n   * RTC handler instance.\n   */\n  get handler() {\n    return this._handler;\n  }\n  /**\n   * Connection state.\n   */\n  get connectionState() {\n    return this._connectionState;\n  }\n  /**\n   * App custom data.\n   */\n  get appData() {\n    return this._appData;\n  }\n  /**\n   * Invalid setter.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  set appData(appData) {\n    throw new Error('cannot override appData object');\n  }\n  get observer() {\n    return this._observer;\n  }\n  /**\n   * Close the Transport.\n   */\n  close() {\n    if (this._closed) return;\n    logger.debug('close()');\n    this._closed = true;\n    // Stop the AwaitQueue.\n    this._awaitQueue.stop();\n    // Close the handler.\n    this._handler.close();\n    // Close all Producers.\n    for (const producer of this._producers.values()) {\n      producer.transportClosed();\n    }\n    this._producers.clear();\n    // Close all Consumers.\n    for (const consumer of this._consumers.values()) {\n      consumer.transportClosed();\n    }\n    this._consumers.clear();\n    // Close all DataProducers.\n    for (const dataProducer of this._dataProducers.values()) {\n      dataProducer.transportClosed();\n    }\n    this._dataProducers.clear();\n    // Close all DataConsumers.\n    for (const dataConsumer of this._dataConsumers.values()) {\n      dataConsumer.transportClosed();\n    }\n    this._dataConsumers.clear();\n    // Emit observer event.\n    this._observer.safeEmit('close');\n  }\n  /**\n   * Get associated Transport (RTCPeerConnection) stats.\n   *\n   * @returns {RTCStatsReport}\n   */\n  async getStats() {\n    if (this._closed) throw new errors_1.InvalidStateError('closed');\n    return this._handler.getTransportStats();\n  }\n  /**\n   * Restart ICE connection.\n   */\n  async restartIce(_ref2) {\n    let {\n      iceParameters\n    } = _ref2;\n    logger.debug('restartIce()');\n    if (this._closed) throw new errors_1.InvalidStateError('closed');else if (!iceParameters) throw new TypeError('missing iceParameters');\n    // Enqueue command.\n    return this._awaitQueue.push(async () => this._handler.restartIce(iceParameters), 'transport.restartIce()');\n  }\n  /**\n   * Update ICE servers.\n   */\n  async updateIceServers() {\n    let {\n      iceServers\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    logger.debug('updateIceServers()');\n    if (this._closed) throw new errors_1.InvalidStateError('closed');else if (!Array.isArray(iceServers)) throw new TypeError('missing iceServers');\n    // Enqueue command.\n    return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), 'transport.updateIceServers()');\n  }\n  /**\n   * Create a Producer.\n   */\n  async produce() {\n    let {\n      track,\n      encodings,\n      codecOptions,\n      codec,\n      stopTracks = true,\n      disableTrackOnPause = true,\n      zeroRtpOnPause = false,\n      appData = {}\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    logger.debug('produce() [track:%o]', track);\n    if (this._closed) throw new errors_1.InvalidStateError('closed');else if (!track) throw new TypeError('missing track');else if (this._direction !== 'send') throw new errors_1.UnsupportedError('not a sending Transport');else if (!this._canProduceByKind[track.kind]) throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);else if (track.readyState === 'ended') throw new errors_1.InvalidStateError('track ended');else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') throw new TypeError('no \"connect\" listener set into this transport');else if (this.listenerCount('produce') === 0) throw new TypeError('no \"produce\" listener set into this transport');else if (appData && typeof appData !== 'object') throw new TypeError('if given, appData must be an object');\n    // Enqueue command.\n    return this._awaitQueue.push(async () => {\n      let normalizedEncodings;\n      if (encodings && !Array.isArray(encodings)) {\n        throw TypeError('encodings must be an array');\n      } else if (encodings && encodings.length === 0) {\n        normalizedEncodings = undefined;\n      } else if (encodings) {\n        normalizedEncodings = encodings.map(encoding => {\n          const normalizedEncoding = {\n            active: true\n          };\n          if (encoding.active === false) normalizedEncoding.active = false;\n          if (typeof encoding.dtx === 'boolean') normalizedEncoding.dtx = encoding.dtx;\n          if (typeof encoding.scalabilityMode === 'string') normalizedEncoding.scalabilityMode = encoding.scalabilityMode;\n          if (typeof encoding.scaleResolutionDownBy === 'number') normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;\n          if (typeof encoding.maxBitrate === 'number') normalizedEncoding.maxBitrate = encoding.maxBitrate;\n          if (typeof encoding.maxFramerate === 'number') normalizedEncoding.maxFramerate = encoding.maxFramerate;\n          if (typeof encoding.adaptivePtime === 'boolean') normalizedEncoding.adaptivePtime = encoding.adaptivePtime;\n          if (typeof encoding.priority === 'string') normalizedEncoding.priority = encoding.priority;\n          if (typeof encoding.networkPriority === 'string') normalizedEncoding.networkPriority = encoding.networkPriority;\n          return normalizedEncoding;\n        });\n      }\n      const {\n        localId,\n        rtpParameters,\n        rtpSender\n      } = await this._handler.send({\n        track,\n        encodings: normalizedEncodings,\n        codecOptions,\n        codec\n      });\n      try {\n        // This will fill rtpParameters's missing fields with default values.\n        ortc.validateRtpParameters(rtpParameters);\n        const {\n          id\n        } = await new Promise((resolve, reject) => {\n          this.safeEmit('produce', {\n            kind: track.kind,\n            rtpParameters,\n            appData\n          }, resolve, reject);\n        });\n        const producer = new Producer_1.Producer({\n          id,\n          localId,\n          rtpSender,\n          track,\n          rtpParameters,\n          stopTracks,\n          disableTrackOnPause,\n          zeroRtpOnPause,\n          appData\n        });\n        this._producers.set(producer.id, producer);\n        this.handleProducer(producer);\n        // Emit observer event.\n        this._observer.safeEmit('newproducer', producer);\n        return producer;\n      } catch (error) {\n        this._handler.stopSending(localId).catch(() => {});\n        throw error;\n      }\n    }, 'transport.produce()')\n    // This catch is needed to stop the given track if the command above\n    // failed due to closed Transport.\n    .catch(error => {\n      if (stopTracks) {\n        try {\n          track.stop();\n        } catch (error2) {}\n      }\n      throw error;\n    });\n  }\n  /**\n   * Create a Consumer to consume a remote Producer.\n   */\n  async consume(_ref3) {\n    let {\n      id,\n      producerId,\n      kind,\n      rtpParameters,\n      streamId,\n      appData = {}\n    } = _ref3;\n    logger.debug('consume()');\n    rtpParameters = utils.clone(rtpParameters, undefined);\n    if (this._closed) throw new errors_1.InvalidStateError('closed');else if (this._direction !== 'recv') throw new errors_1.UnsupportedError('not a receiving Transport');else if (typeof id !== 'string') throw new TypeError('missing id');else if (typeof producerId !== 'string') throw new TypeError('missing producerId');else if (kind !== 'audio' && kind !== 'video') throw new TypeError(`invalid kind '${kind}'`);else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') throw new TypeError('no \"connect\" listener set into this transport');else if (appData && typeof appData !== 'object') throw new TypeError('if given, appData must be an object');\n    // Ensure the device can consume it.\n    const canConsume = ortc.canReceive(rtpParameters, this._extendedRtpCapabilities);\n    if (!canConsume) throw new errors_1.UnsupportedError('cannot consume this Producer');\n    const consumerCreationTask = new ConsumerCreationTask({\n      id,\n      producerId,\n      kind,\n      rtpParameters,\n      streamId,\n      appData\n    });\n    // Store the Consumer creation task.\n    this._pendingConsumerTasks.push(consumerCreationTask);\n    // There is no Consumer creation in progress, create it now.\n    if (this._consumerCreationInProgress === false) {\n      this.createPendingConsumers();\n    }\n    return consumerCreationTask.promise;\n  }\n  /**\n   * Create a DataProducer\n   */\n  async produceData() {\n    let {\n      ordered = true,\n      maxPacketLifeTime,\n      maxRetransmits,\n      label = '',\n      protocol = '',\n      appData = {}\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    logger.debug('produceData()');\n    if (this._closed) throw new errors_1.InvalidStateError('closed');else if (this._direction !== 'send') throw new errors_1.UnsupportedError('not a sending Transport');else if (!this._maxSctpMessageSize) throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') throw new TypeError('no \"connect\" listener set into this transport');else if (this.listenerCount('producedata') === 0) throw new TypeError('no \"producedata\" listener set into this transport');else if (appData && typeof appData !== 'object') throw new TypeError('if given, appData must be an object');\n    if (maxPacketLifeTime || maxRetransmits) ordered = false;\n    // Enqueue command.\n    return this._awaitQueue.push(async () => {\n      const {\n        dataChannel,\n        sctpStreamParameters\n      } = await this._handler.sendDataChannel({\n        ordered,\n        maxPacketLifeTime,\n        maxRetransmits,\n        label,\n        protocol\n      });\n      // This will fill sctpStreamParameters's missing fields with default values.\n      ortc.validateSctpStreamParameters(sctpStreamParameters);\n      const {\n        id\n      } = await new Promise((resolve, reject) => {\n        this.safeEmit('producedata', {\n          sctpStreamParameters,\n          label,\n          protocol,\n          appData\n        }, resolve, reject);\n      });\n      const dataProducer = new DataProducer_1.DataProducer({\n        id,\n        dataChannel,\n        sctpStreamParameters,\n        appData\n      });\n      this._dataProducers.set(dataProducer.id, dataProducer);\n      this.handleDataProducer(dataProducer);\n      // Emit observer event.\n      this._observer.safeEmit('newdataproducer', dataProducer);\n      return dataProducer;\n    }, 'transport.produceData()');\n  }\n  /**\n   * Create a DataConsumer\n   */\n  async consumeData(_ref4) {\n    let {\n      id,\n      dataProducerId,\n      sctpStreamParameters,\n      label = '',\n      protocol = '',\n      appData = {}\n    } = _ref4;\n    logger.debug('consumeData()');\n    sctpStreamParameters = utils.clone(sctpStreamParameters, undefined);\n    if (this._closed) throw new errors_1.InvalidStateError('closed');else if (this._direction !== 'recv') throw new errors_1.UnsupportedError('not a receiving Transport');else if (!this._maxSctpMessageSize) throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');else if (typeof id !== 'string') throw new TypeError('missing id');else if (typeof dataProducerId !== 'string') throw new TypeError('missing dataProducerId');else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') throw new TypeError('no \"connect\" listener set into this transport');else if (appData && typeof appData !== 'object') throw new TypeError('if given, appData must be an object');\n    // This may throw.\n    ortc.validateSctpStreamParameters(sctpStreamParameters);\n    // Enqueue command.\n    return this._awaitQueue.push(async () => {\n      const {\n        dataChannel\n      } = await this._handler.receiveDataChannel({\n        sctpStreamParameters,\n        label,\n        protocol\n      });\n      const dataConsumer = new DataConsumer_1.DataConsumer({\n        id,\n        dataProducerId,\n        dataChannel,\n        sctpStreamParameters,\n        appData\n      });\n      this._dataConsumers.set(dataConsumer.id, dataConsumer);\n      this.handleDataConsumer(dataConsumer);\n      // Emit observer event.\n      this._observer.safeEmit('newdataconsumer', dataConsumer);\n      return dataConsumer;\n    }, 'transport.consumeData()');\n  }\n  // This method is guaranteed to never throw.\n  async createPendingConsumers() {\n    this._consumerCreationInProgress = true;\n    this._awaitQueue.push(async () => {\n      if (this._pendingConsumerTasks.length === 0) {\n        logger.debug('createPendingConsumers() | there is no Consumer to be created');\n        return;\n      }\n      const pendingConsumerTasks = [...this._pendingConsumerTasks];\n      // Clear pending Consumer tasks.\n      this._pendingConsumerTasks = [];\n      // Video Consumer in order to create the probator.\n      let videoConsumerForProbator = undefined;\n      // Fill options list.\n      const optionsList = [];\n      for (const task of pendingConsumerTasks) {\n        const {\n          id,\n          kind,\n          rtpParameters,\n          streamId\n        } = task.consumerOptions;\n        optionsList.push({\n          trackId: id,\n          kind: kind,\n          rtpParameters,\n          streamId\n        });\n      }\n      try {\n        const results = await this._handler.receive(optionsList);\n        for (let idx = 0; idx < results.length; idx++) {\n          const task = pendingConsumerTasks[idx];\n          const result = results[idx];\n          const {\n            id,\n            producerId,\n            kind,\n            rtpParameters,\n            appData\n          } = task.consumerOptions;\n          const {\n            localId,\n            rtpReceiver,\n            track\n          } = result;\n          const consumer = new Consumer_1.Consumer({\n            id: id,\n            localId,\n            producerId: producerId,\n            rtpReceiver,\n            track,\n            rtpParameters,\n            appData\n          });\n          this._consumers.set(consumer.id, consumer);\n          this.handleConsumer(consumer);\n          // If this is the first video Consumer and the Consumer for RTP probation\n          // has not yet been created, it's time to create it.\n          if (!this._probatorConsumerCreated && !videoConsumerForProbator && kind === 'video') {\n            videoConsumerForProbator = consumer;\n          }\n          // Emit observer event.\n          this._observer.safeEmit('newconsumer', consumer);\n          task.resolve(consumer);\n        }\n      } catch (error) {\n        for (const task of pendingConsumerTasks) {\n          task.reject(error);\n        }\n      }\n      // If RTP probation must be handled, do it now.\n      if (videoConsumerForProbator) {\n        try {\n          const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);\n          await this._handler.receive([{\n            trackId: 'probator',\n            kind: 'video',\n            rtpParameters: probatorRtpParameters\n          }]);\n          logger.debug('createPendingConsumers() | Consumer for RTP probation created');\n          this._probatorConsumerCreated = true;\n        } catch (error) {\n          logger.error('createPendingConsumers() | failed to create Consumer for RTP probation:%o', error);\n        }\n      }\n    }, 'transport.createPendingConsumers()').then(() => {\n      this._consumerCreationInProgress = false;\n      // There are pending Consumer tasks, enqueue their creation.\n      if (this._pendingConsumerTasks.length > 0) {\n        this.createPendingConsumers();\n      }\n    })\n    // NOTE: We only get here when the await queue is closed.\n    .catch(() => {});\n  }\n  pausePendingConsumers() {\n    this._consumerPauseInProgress = true;\n    this._awaitQueue.push(async () => {\n      if (this._pendingPauseConsumers.size === 0) {\n        logger.debug('pausePendingConsumers() | there is no Consumer to be paused');\n        return;\n      }\n      const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());\n      // Clear pending pause Consumer map.\n      this._pendingPauseConsumers.clear();\n      try {\n        const localIds = pendingPauseConsumers.map(consumer => consumer.localId);\n        await this._handler.pauseReceiving(localIds);\n      } catch (error) {\n        logger.error('pausePendingConsumers() | failed to pause Consumers:', error);\n      }\n    }, 'transport.pausePendingConsumers').then(() => {\n      this._consumerPauseInProgress = false;\n      // There are pending Consumers to be paused, do it.\n      if (this._pendingPauseConsumers.size > 0) {\n        this.pausePendingConsumers();\n      }\n    })\n    // NOTE: We only get here when the await queue is closed.\n    .catch(() => {});\n  }\n  resumePendingConsumers() {\n    this._consumerResumeInProgress = true;\n    this._awaitQueue.push(async () => {\n      if (this._pendingResumeConsumers.size === 0) {\n        logger.debug('resumePendingConsumers() | there is no Consumer to be resumed');\n        return;\n      }\n      const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());\n      // Clear pending resume Consumer map.\n      this._pendingResumeConsumers.clear();\n      try {\n        const localIds = pendingResumeConsumers.map(consumer => consumer.localId);\n        await this._handler.resumeReceiving(localIds);\n      } catch (error) {\n        logger.error('resumePendingConsumers() | failed to resume Consumers:', error);\n      }\n    }, 'transport.resumePendingConsumers').then(() => {\n      this._consumerResumeInProgress = false;\n      // There are pending Consumer to be resumed, do it.\n      if (this._pendingResumeConsumers.size > 0) {\n        this.resumePendingConsumers();\n      }\n    })\n    // NOTE: We only get here when the await queue is closed.\n    .catch(() => {});\n  }\n  closePendingConsumers() {\n    this._consumerCloseInProgress = true;\n    this._awaitQueue.push(async () => {\n      if (this._pendingCloseConsumers.size === 0) {\n        logger.debug('closePendingConsumers() | there is no Consumer to be closed');\n        return;\n      }\n      const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());\n      // Clear pending close Consumer map.\n      this._pendingCloseConsumers.clear();\n      try {\n        await this._handler.stopReceiving(pendingCloseConsumers.map(consumer => consumer.localId));\n      } catch (error) {\n        logger.error('closePendingConsumers() | failed to close Consumers:', error);\n      }\n    }, 'transport.closePendingConsumers').then(() => {\n      this._consumerCloseInProgress = false;\n      // There are pending Consumer to be resumed, do it.\n      if (this._pendingCloseConsumers.size > 0) {\n        this.closePendingConsumers();\n      }\n    })\n    // NOTE: We only get here when the await queue is closed.\n    .catch(() => {});\n  }\n  handleHandler() {\n    const handler = this._handler;\n    handler.on('@connect', (_ref5, callback, errback) => {\n      let {\n        dtlsParameters\n      } = _ref5;\n      if (this._closed) {\n        errback(new errors_1.InvalidStateError('closed'));\n        return;\n      }\n      this.safeEmit('connect', {\n        dtlsParameters\n      }, callback, errback);\n    });\n    handler.on('@connectionstatechange', connectionState => {\n      if (connectionState === this._connectionState) return;\n      logger.debug('connection state changed to %s', connectionState);\n      this._connectionState = connectionState;\n      if (!this._closed) this.safeEmit('connectionstatechange', connectionState);\n    });\n  }\n  handleProducer(producer) {\n    producer.on('@close', () => {\n      this._producers.delete(producer.id);\n      if (this._closed) return;\n      this._awaitQueue.push(async () => this._handler.stopSending(producer.localId), 'producer @close event').catch(error => logger.warn('producer.close() failed:%o', error));\n    });\n    producer.on('@pause', (callback, errback) => {\n      this._awaitQueue.push(async () => this._handler.pauseSending(producer.localId), 'producer @pause event').then(callback).catch(errback);\n    });\n    producer.on('@resume', (callback, errback) => {\n      this._awaitQueue.push(async () => this._handler.resumeSending(producer.localId), 'producer @resume event').then(callback).catch(errback);\n    });\n    producer.on('@replacetrack', (track, callback, errback) => {\n      this._awaitQueue.push(async () => this._handler.replaceTrack(producer.localId, track), 'producer @replacetrack event').then(callback).catch(errback);\n    });\n    producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {\n      this._awaitQueue.push(async () => this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), 'producer @setmaxspatiallayer event').then(callback).catch(errback);\n    });\n    producer.on('@setrtpencodingparameters', (params, callback, errback) => {\n      this._awaitQueue.push(async () => this._handler.setRtpEncodingParameters(producer.localId, params), 'producer @setrtpencodingparameters event').then(callback).catch(errback);\n    });\n    producer.on('@getstats', (callback, errback) => {\n      if (this._closed) return errback(new errors_1.InvalidStateError('closed'));\n      this._handler.getSenderStats(producer.localId).then(callback).catch(errback);\n    });\n  }\n  handleConsumer(consumer) {\n    consumer.on('@close', () => {\n      this._consumers.delete(consumer.id);\n      this._pendingPauseConsumers.delete(consumer.id);\n      this._pendingResumeConsumers.delete(consumer.id);\n      if (this._closed) return;\n      // Store the Consumer into the close list.\n      this._pendingCloseConsumers.set(consumer.id, consumer);\n      // There is no Consumer close in progress, do it now.\n      if (this._consumerCloseInProgress === false) {\n        this.closePendingConsumers();\n      }\n    });\n    consumer.on('@pause', () => {\n      // If Consumer is pending to be resumed, remove from pending resume list.\n      if (this._pendingResumeConsumers.has(consumer.id)) {\n        this._pendingResumeConsumers.delete(consumer.id);\n      }\n      // Store the Consumer into the pending list.\n      this._pendingPauseConsumers.set(consumer.id, consumer);\n      // There is no Consumer pause in progress, do it now.\n      if (this._consumerPauseInProgress === false) {\n        this.pausePendingConsumers();\n      }\n    });\n    consumer.on('@resume', () => {\n      // If Consumer is pending to be paused, remove from pending pause list.\n      if (this._pendingPauseConsumers.has(consumer.id)) {\n        this._pendingPauseConsumers.delete(consumer.id);\n      }\n      // Store the Consumer into the pending list.\n      this._pendingResumeConsumers.set(consumer.id, consumer);\n      // There is no Consumer resume in progress, do it now.\n      if (this._consumerResumeInProgress === false) {\n        this.resumePendingConsumers();\n      }\n    });\n    consumer.on('@getstats', (callback, errback) => {\n      if (this._closed) return errback(new errors_1.InvalidStateError('closed'));\n      this._handler.getReceiverStats(consumer.localId).then(callback).catch(errback);\n    });\n  }\n  handleDataProducer(dataProducer) {\n    dataProducer.on('@close', () => {\n      this._dataProducers.delete(dataProducer.id);\n    });\n  }\n  handleDataConsumer(dataConsumer) {\n    dataConsumer.on('@close', () => {\n      this._dataConsumers.delete(dataConsumer.id);\n    });\n  }\n}\nexports.Transport = Transport;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","Transport","awaitqueue_1","require","Logger_1","EnhancedEventEmitter_1","errors_1","utils","ortc","Producer_1","Consumer_1","DataProducer_1","DataConsumer_1","logger","Logger","ConsumerCreationTask","constructor","consumerOptions","promise","Promise","resolve","reject","EnhancedEventEmitter","direction","id","iceParameters","iceCandidates","dtlsParameters","sctpParameters","iceServers","iceTransportPolicy","additionalSettings","proprietaryConstraints","appData","handlerFactory","extendedRtpCapabilities","canProduceByKind","_closed","_connectionState","_producers","Map","_consumers","_dataProducers","_dataConsumers","_probatorConsumerCreated","_awaitQueue","AwaitQueue","_pendingConsumerTasks","_consumerCreationInProgress","_pendingPauseConsumers","_consumerPauseInProgress","_pendingResumeConsumers","_consumerResumeInProgress","_pendingCloseConsumers","_consumerCloseInProgress","_observer","debug","_id","_direction","_extendedRtpCapabilities","_canProduceByKind","_maxSctpMessageSize","maxMessageSize","clone","bundlePolicy","rtcpMuxPolicy","sdpSemantics","_handler","run","_appData","handleHandler","closed","handler","connectionState","Error","observer","close","stop","producer","values","transportClosed","clear","consumer","dataProducer","dataConsumer","safeEmit","getStats","InvalidStateError","getTransportStats","restartIce","TypeError","push","updateIceServers","Array","isArray","produce","track","encodings","codecOptions","codec","stopTracks","disableTrackOnPause","zeroRtpOnPause","UnsupportedError","kind","readyState","listenerCount","normalizedEncodings","length","map","encoding","normalizedEncoding","active","dtx","scalabilityMode","scaleResolutionDownBy","maxBitrate","maxFramerate","adaptivePtime","priority","networkPriority","localId","rtpParameters","rtpSender","send","validateRtpParameters","Producer","set","handleProducer","error","stopSending","catch","error2","consume","producerId","streamId","canConsume","canReceive","consumerCreationTask","createPendingConsumers","produceData","ordered","maxPacketLifeTime","maxRetransmits","label","protocol","dataChannel","sctpStreamParameters","sendDataChannel","validateSctpStreamParameters","DataProducer","handleDataProducer","consumeData","dataProducerId","receiveDataChannel","DataConsumer","handleDataConsumer","pendingConsumerTasks","videoConsumerForProbator","optionsList","task","trackId","results","receive","idx","rtpReceiver","Consumer","handleConsumer","probatorRtpParameters","generateProbatorRtpParameters","then","pausePendingConsumers","size","pendingPauseConsumers","from","localIds","pauseReceiving","resumePendingConsumers","pendingResumeConsumers","resumeReceiving","closePendingConsumers","pendingCloseConsumers","stopReceiving","on","callback","errback","delete","warn","pauseSending","resumeSending","replaceTrack","spatialLayer","setMaxSpatialLayer","params","setRtpEncodingParameters","getSenderStats","has","getReceiverStats"],"sources":["/Users/user/Desktop/solana-hack-1/client/node_modules/mediasoup-client/lib/Transport.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transport = void 0;\nconst awaitqueue_1 = require(\"awaitqueue\");\nconst Logger_1 = require(\"./Logger\");\nconst EnhancedEventEmitter_1 = require(\"./EnhancedEventEmitter\");\nconst errors_1 = require(\"./errors\");\nconst utils = __importStar(require(\"./utils\"));\nconst ortc = __importStar(require(\"./ortc\"));\nconst Producer_1 = require(\"./Producer\");\nconst Consumer_1 = require(\"./Consumer\");\nconst DataProducer_1 = require(\"./DataProducer\");\nconst DataConsumer_1 = require(\"./DataConsumer\");\nconst logger = new Logger_1.Logger('Transport');\nclass ConsumerCreationTask {\n    constructor(consumerOptions) {\n        this.consumerOptions = consumerOptions;\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\nclass Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Transport connection state.\n        this._connectionState = 'new';\n        // Map of Producers indexed by id.\n        this._producers = new Map();\n        // Map of Consumers indexed by id.\n        this._consumers = new Map();\n        // Map of DataProducers indexed by id.\n        this._dataProducers = new Map();\n        // Map of DataConsumers indexed by id.\n        this._dataConsumers = new Map();\n        // Whether the Consumer for RTP probation has been created.\n        this._probatorConsumerCreated = false;\n        // AwaitQueue instance to make async tasks happen sequentially.\n        this._awaitQueue = new awaitqueue_1.AwaitQueue();\n        // Consumer creation tasks awaiting to be processed.\n        this._pendingConsumerTasks = [];\n        // Consumer creation in progress flag.\n        this._consumerCreationInProgress = false;\n        // Consumers pending to be paused.\n        this._pendingPauseConsumers = new Map();\n        // Consumer pause in progress flag.\n        this._consumerPauseInProgress = false;\n        // Consumers pending to be resumed.\n        this._pendingResumeConsumers = new Map();\n        // Consumer resume in progress flag.\n        this._consumerResumeInProgress = false;\n        // Consumers pending to be closed.\n        this._pendingCloseConsumers = new Map();\n        // Consumer close in progress flag.\n        this._consumerCloseInProgress = false;\n        // Observer instance.\n        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();\n        logger.debug('constructor() [id:%s, direction:%s]', id, direction);\n        this._id = id;\n        this._direction = direction;\n        this._extendedRtpCapabilities = extendedRtpCapabilities;\n        this._canProduceByKind = canProduceByKind;\n        this._maxSctpMessageSize =\n            sctpParameters ? sctpParameters.maxMessageSize : null;\n        // Clone and sanitize additionalSettings.\n        additionalSettings = utils.clone(additionalSettings, {});\n        delete additionalSettings.iceServers;\n        delete additionalSettings.iceTransportPolicy;\n        delete additionalSettings.bundlePolicy;\n        delete additionalSettings.rtcpMuxPolicy;\n        delete additionalSettings.sdpSemantics;\n        this._handler = handlerFactory();\n        this._handler.run({\n            direction,\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            iceServers,\n            iceTransportPolicy,\n            additionalSettings,\n            proprietaryConstraints,\n            extendedRtpCapabilities\n        });\n        this._appData = appData || {};\n        this.handleHandler();\n    }\n    /**\n     * Transport id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Whether the Transport is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * Transport direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * RTC handler instance.\n     */\n    get handler() {\n        return this._handler;\n    }\n    /**\n     * Connection state.\n     */\n    get connectionState() {\n        return this._connectionState;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    set appData(appData) {\n        throw new Error('cannot override appData object');\n    }\n    get observer() {\n        return this._observer;\n    }\n    /**\n     * Close the Transport.\n     */\n    close() {\n        if (this._closed)\n            return;\n        logger.debug('close()');\n        this._closed = true;\n        // Stop the AwaitQueue.\n        this._awaitQueue.stop();\n        // Close the handler.\n        this._handler.close();\n        // Close all Producers.\n        for (const producer of this._producers.values()) {\n            producer.transportClosed();\n        }\n        this._producers.clear();\n        // Close all Consumers.\n        for (const consumer of this._consumers.values()) {\n            consumer.transportClosed();\n        }\n        this._consumers.clear();\n        // Close all DataProducers.\n        for (const dataProducer of this._dataProducers.values()) {\n            dataProducer.transportClosed();\n        }\n        this._dataProducers.clear();\n        // Close all DataConsumers.\n        for (const dataConsumer of this._dataConsumers.values()) {\n            dataConsumer.transportClosed();\n        }\n        this._dataConsumers.clear();\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Get associated Transport (RTCPeerConnection) stats.\n     *\n     * @returns {RTCStatsReport}\n     */\n    async getStats() {\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        return this._handler.getTransportStats();\n    }\n    /**\n     * Restart ICE connection.\n     */\n    async restartIce({ iceParameters }) {\n        logger.debug('restartIce()');\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (!iceParameters)\n            throw new TypeError('missing iceParameters');\n        // Enqueue command.\n        return this._awaitQueue.push(async () => this._handler.restartIce(iceParameters), 'transport.restartIce()');\n    }\n    /**\n     * Update ICE servers.\n     */\n    async updateIceServers({ iceServers } = {}) {\n        logger.debug('updateIceServers()');\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (!Array.isArray(iceServers))\n            throw new TypeError('missing iceServers');\n        // Enqueue command.\n        return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), 'transport.updateIceServers()');\n    }\n    /**\n     * Create a Producer.\n     */\n    async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, appData = {} } = {}) {\n        logger.debug('produce() [track:%o]', track);\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (!track)\n            throw new TypeError('missing track');\n        else if (this._direction !== 'send')\n            throw new errors_1.UnsupportedError('not a sending Transport');\n        else if (!this._canProduceByKind[track.kind])\n            throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);\n        else if (track.readyState === 'ended')\n            throw new errors_1.InvalidStateError('track ended');\n        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\n            throw new TypeError('no \"connect\" listener set into this transport');\n        else if (this.listenerCount('produce') === 0)\n            throw new TypeError('no \"produce\" listener set into this transport');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            let normalizedEncodings;\n            if (encodings && !Array.isArray(encodings)) {\n                throw TypeError('encodings must be an array');\n            }\n            else if (encodings && encodings.length === 0) {\n                normalizedEncodings = undefined;\n            }\n            else if (encodings) {\n                normalizedEncodings = encodings\n                    .map((encoding) => {\n                    const normalizedEncoding = { active: true };\n                    if (encoding.active === false)\n                        normalizedEncoding.active = false;\n                    if (typeof encoding.dtx === 'boolean')\n                        normalizedEncoding.dtx = encoding.dtx;\n                    if (typeof encoding.scalabilityMode === 'string')\n                        normalizedEncoding.scalabilityMode = encoding.scalabilityMode;\n                    if (typeof encoding.scaleResolutionDownBy === 'number')\n                        normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;\n                    if (typeof encoding.maxBitrate === 'number')\n                        normalizedEncoding.maxBitrate = encoding.maxBitrate;\n                    if (typeof encoding.maxFramerate === 'number')\n                        normalizedEncoding.maxFramerate = encoding.maxFramerate;\n                    if (typeof encoding.adaptivePtime === 'boolean')\n                        normalizedEncoding.adaptivePtime = encoding.adaptivePtime;\n                    if (typeof encoding.priority === 'string')\n                        normalizedEncoding.priority = encoding.priority;\n                    if (typeof encoding.networkPriority === 'string')\n                        normalizedEncoding.networkPriority = encoding.networkPriority;\n                    return normalizedEncoding;\n                });\n            }\n            const { localId, rtpParameters, rtpSender } = await this._handler.send({\n                track,\n                encodings: normalizedEncodings,\n                codecOptions,\n                codec\n            });\n            try {\n                // This will fill rtpParameters's missing fields with default values.\n                ortc.validateRtpParameters(rtpParameters);\n                const { id } = await new Promise((resolve, reject) => {\n                    this.safeEmit('produce', {\n                        kind: track.kind,\n                        rtpParameters,\n                        appData\n                    }, resolve, reject);\n                });\n                const producer = new Producer_1.Producer({\n                    id,\n                    localId,\n                    rtpSender,\n                    track,\n                    rtpParameters,\n                    stopTracks,\n                    disableTrackOnPause,\n                    zeroRtpOnPause,\n                    appData\n                });\n                this._producers.set(producer.id, producer);\n                this.handleProducer(producer);\n                // Emit observer event.\n                this._observer.safeEmit('newproducer', producer);\n                return producer;\n            }\n            catch (error) {\n                this._handler.stopSending(localId)\n                    .catch(() => { });\n                throw error;\n            }\n        }, 'transport.produce()')\n            // This catch is needed to stop the given track if the command above\n            // failed due to closed Transport.\n            .catch((error) => {\n            if (stopTracks) {\n                try {\n                    track.stop();\n                }\n                catch (error2) { }\n            }\n            throw error;\n        });\n    }\n    /**\n     * Create a Consumer to consume a remote Producer.\n     */\n    async consume({ id, producerId, kind, rtpParameters, streamId, appData = {} }) {\n        logger.debug('consume()');\n        rtpParameters = utils.clone(rtpParameters, undefined);\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (this._direction !== 'recv')\n            throw new errors_1.UnsupportedError('not a receiving Transport');\n        else if (typeof id !== 'string')\n            throw new TypeError('missing id');\n        else if (typeof producerId !== 'string')\n            throw new TypeError('missing producerId');\n        else if (kind !== 'audio' && kind !== 'video')\n            throw new TypeError(`invalid kind '${kind}'`);\n        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\n            throw new TypeError('no \"connect\" listener set into this transport');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        // Ensure the device can consume it.\n        const canConsume = ortc.canReceive(rtpParameters, this._extendedRtpCapabilities);\n        if (!canConsume)\n            throw new errors_1.UnsupportedError('cannot consume this Producer');\n        const consumerCreationTask = new ConsumerCreationTask({\n            id,\n            producerId,\n            kind,\n            rtpParameters,\n            streamId,\n            appData\n        });\n        // Store the Consumer creation task.\n        this._pendingConsumerTasks.push(consumerCreationTask);\n        // There is no Consumer creation in progress, create it now.\n        if (this._consumerCreationInProgress === false) {\n            this.createPendingConsumers();\n        }\n        return consumerCreationTask.promise;\n    }\n    /**\n     * Create a DataProducer\n     */\n    async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = '', protocol = '', appData = {} } = {}) {\n        logger.debug('produceData()');\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (this._direction !== 'send')\n            throw new errors_1.UnsupportedError('not a sending Transport');\n        else if (!this._maxSctpMessageSize)\n            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\n            throw new TypeError('no \"connect\" listener set into this transport');\n        else if (this.listenerCount('producedata') === 0)\n            throw new TypeError('no \"producedata\" listener set into this transport');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        if (maxPacketLifeTime || maxRetransmits)\n            ordered = false;\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({\n                ordered,\n                maxPacketLifeTime,\n                maxRetransmits,\n                label,\n                protocol\n            });\n            // This will fill sctpStreamParameters's missing fields with default values.\n            ortc.validateSctpStreamParameters(sctpStreamParameters);\n            const { id } = await new Promise((resolve, reject) => {\n                this.safeEmit('producedata', {\n                    sctpStreamParameters,\n                    label,\n                    protocol,\n                    appData\n                }, resolve, reject);\n            });\n            const dataProducer = new DataProducer_1.DataProducer({ id, dataChannel, sctpStreamParameters, appData });\n            this._dataProducers.set(dataProducer.id, dataProducer);\n            this.handleDataProducer(dataProducer);\n            // Emit observer event.\n            this._observer.safeEmit('newdataproducer', dataProducer);\n            return dataProducer;\n        }, 'transport.produceData()');\n    }\n    /**\n     * Create a DataConsumer\n     */\n    async consumeData({ id, dataProducerId, sctpStreamParameters, label = '', protocol = '', appData = {} }) {\n        logger.debug('consumeData()');\n        sctpStreamParameters = utils.clone(sctpStreamParameters, undefined);\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (this._direction !== 'recv')\n            throw new errors_1.UnsupportedError('not a receiving Transport');\n        else if (!this._maxSctpMessageSize)\n            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n        else if (typeof id !== 'string')\n            throw new TypeError('missing id');\n        else if (typeof dataProducerId !== 'string')\n            throw new TypeError('missing dataProducerId');\n        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\n            throw new TypeError('no \"connect\" listener set into this transport');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        // This may throw.\n        ortc.validateSctpStreamParameters(sctpStreamParameters);\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            const { dataChannel } = await this._handler.receiveDataChannel({\n                sctpStreamParameters,\n                label,\n                protocol\n            });\n            const dataConsumer = new DataConsumer_1.DataConsumer({\n                id,\n                dataProducerId,\n                dataChannel,\n                sctpStreamParameters,\n                appData\n            });\n            this._dataConsumers.set(dataConsumer.id, dataConsumer);\n            this.handleDataConsumer(dataConsumer);\n            // Emit observer event.\n            this._observer.safeEmit('newdataconsumer', dataConsumer);\n            return dataConsumer;\n        }, 'transport.consumeData()');\n    }\n    // This method is guaranteed to never throw.\n    async createPendingConsumers() {\n        this._consumerCreationInProgress = true;\n        this._awaitQueue.push(async () => {\n            if (this._pendingConsumerTasks.length === 0) {\n                logger.debug('createPendingConsumers() | there is no Consumer to be created');\n                return;\n            }\n            const pendingConsumerTasks = [...this._pendingConsumerTasks];\n            // Clear pending Consumer tasks.\n            this._pendingConsumerTasks = [];\n            // Video Consumer in order to create the probator.\n            let videoConsumerForProbator = undefined;\n            // Fill options list.\n            const optionsList = [];\n            for (const task of pendingConsumerTasks) {\n                const { id, kind, rtpParameters, streamId } = task.consumerOptions;\n                optionsList.push({\n                    trackId: id,\n                    kind: kind,\n                    rtpParameters,\n                    streamId\n                });\n            }\n            try {\n                const results = await this._handler.receive(optionsList);\n                for (let idx = 0; idx < results.length; idx++) {\n                    const task = pendingConsumerTasks[idx];\n                    const result = results[idx];\n                    const { id, producerId, kind, rtpParameters, appData } = task.consumerOptions;\n                    const { localId, rtpReceiver, track } = result;\n                    const consumer = new Consumer_1.Consumer({\n                        id: id,\n                        localId,\n                        producerId: producerId,\n                        rtpReceiver,\n                        track,\n                        rtpParameters,\n                        appData\n                    });\n                    this._consumers.set(consumer.id, consumer);\n                    this.handleConsumer(consumer);\n                    // If this is the first video Consumer and the Consumer for RTP probation\n                    // has not yet been created, it's time to create it.\n                    if (!this._probatorConsumerCreated && !videoConsumerForProbator && kind === 'video') {\n                        videoConsumerForProbator = consumer;\n                    }\n                    // Emit observer event.\n                    this._observer.safeEmit('newconsumer', consumer);\n                    task.resolve(consumer);\n                }\n            }\n            catch (error) {\n                for (const task of pendingConsumerTasks) {\n                    task.reject(error);\n                }\n            }\n            // If RTP probation must be handled, do it now.\n            if (videoConsumerForProbator) {\n                try {\n                    const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);\n                    await this._handler.receive([{\n                            trackId: 'probator',\n                            kind: 'video',\n                            rtpParameters: probatorRtpParameters\n                        }]);\n                    logger.debug('createPendingConsumers() | Consumer for RTP probation created');\n                    this._probatorConsumerCreated = true;\n                }\n                catch (error) {\n                    logger.error('createPendingConsumers() | failed to create Consumer for RTP probation:%o', error);\n                }\n            }\n        }, 'transport.createPendingConsumers()')\n            .then(() => {\n            this._consumerCreationInProgress = false;\n            // There are pending Consumer tasks, enqueue their creation.\n            if (this._pendingConsumerTasks.length > 0) {\n                this.createPendingConsumers();\n            }\n        })\n            // NOTE: We only get here when the await queue is closed.\n            .catch(() => { });\n    }\n    pausePendingConsumers() {\n        this._consumerPauseInProgress = true;\n        this._awaitQueue.push(async () => {\n            if (this._pendingPauseConsumers.size === 0) {\n                logger.debug('pausePendingConsumers() | there is no Consumer to be paused');\n                return;\n            }\n            const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());\n            // Clear pending pause Consumer map.\n            this._pendingPauseConsumers.clear();\n            try {\n                const localIds = pendingPauseConsumers\n                    .map((consumer) => consumer.localId);\n                await this._handler.pauseReceiving(localIds);\n            }\n            catch (error) {\n                logger.error('pausePendingConsumers() | failed to pause Consumers:', error);\n            }\n        }, 'transport.pausePendingConsumers')\n            .then(() => {\n            this._consumerPauseInProgress = false;\n            // There are pending Consumers to be paused, do it.\n            if (this._pendingPauseConsumers.size > 0) {\n                this.pausePendingConsumers();\n            }\n        })\n            // NOTE: We only get here when the await queue is closed.\n            .catch(() => { });\n    }\n    resumePendingConsumers() {\n        this._consumerResumeInProgress = true;\n        this._awaitQueue.push(async () => {\n            if (this._pendingResumeConsumers.size === 0) {\n                logger.debug('resumePendingConsumers() | there is no Consumer to be resumed');\n                return;\n            }\n            const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());\n            // Clear pending resume Consumer map.\n            this._pendingResumeConsumers.clear();\n            try {\n                const localIds = pendingResumeConsumers\n                    .map((consumer) => consumer.localId);\n                await this._handler.resumeReceiving(localIds);\n            }\n            catch (error) {\n                logger.error('resumePendingConsumers() | failed to resume Consumers:', error);\n            }\n        }, 'transport.resumePendingConsumers')\n            .then(() => {\n            this._consumerResumeInProgress = false;\n            // There are pending Consumer to be resumed, do it.\n            if (this._pendingResumeConsumers.size > 0) {\n                this.resumePendingConsumers();\n            }\n        })\n            // NOTE: We only get here when the await queue is closed.\n            .catch(() => { });\n    }\n    closePendingConsumers() {\n        this._consumerCloseInProgress = true;\n        this._awaitQueue.push(async () => {\n            if (this._pendingCloseConsumers.size === 0) {\n                logger.debug('closePendingConsumers() | there is no Consumer to be closed');\n                return;\n            }\n            const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());\n            // Clear pending close Consumer map.\n            this._pendingCloseConsumers.clear();\n            try {\n                await this._handler.stopReceiving(pendingCloseConsumers.map((consumer) => consumer.localId));\n            }\n            catch (error) {\n                logger.error('closePendingConsumers() | failed to close Consumers:', error);\n            }\n        }, 'transport.closePendingConsumers')\n            .then(() => {\n            this._consumerCloseInProgress = false;\n            // There are pending Consumer to be resumed, do it.\n            if (this._pendingCloseConsumers.size > 0) {\n                this.closePendingConsumers();\n            }\n        })\n            // NOTE: We only get here when the await queue is closed.\n            .catch(() => { });\n    }\n    handleHandler() {\n        const handler = this._handler;\n        handler.on('@connect', ({ dtlsParameters }, callback, errback) => {\n            if (this._closed) {\n                errback(new errors_1.InvalidStateError('closed'));\n                return;\n            }\n            this.safeEmit('connect', { dtlsParameters }, callback, errback);\n        });\n        handler.on('@connectionstatechange', (connectionState) => {\n            if (connectionState === this._connectionState)\n                return;\n            logger.debug('connection state changed to %s', connectionState);\n            this._connectionState = connectionState;\n            if (!this._closed)\n                this.safeEmit('connectionstatechange', connectionState);\n        });\n    }\n    handleProducer(producer) {\n        producer.on('@close', () => {\n            this._producers.delete(producer.id);\n            if (this._closed)\n                return;\n            this._awaitQueue.push(async () => this._handler.stopSending(producer.localId), 'producer @close event')\n                .catch((error) => logger.warn('producer.close() failed:%o', error));\n        });\n        producer.on('@pause', (callback, errback) => {\n            this._awaitQueue.push(async () => this._handler.pauseSending(producer.localId), 'producer @pause event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@resume', (callback, errback) => {\n            this._awaitQueue.push(async () => this._handler.resumeSending(producer.localId), 'producer @resume event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@replacetrack', (track, callback, errback) => {\n            this._awaitQueue.push(async () => this._handler.replaceTrack(producer.localId, track), 'producer @replacetrack event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {\n            this._awaitQueue.push(async () => (this._handler.setMaxSpatialLayer(producer.localId, spatialLayer)), 'producer @setmaxspatiallayer event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@setrtpencodingparameters', (params, callback, errback) => {\n            this._awaitQueue.push(async () => (this._handler.setRtpEncodingParameters(producer.localId, params)), 'producer @setrtpencodingparameters event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@getstats', (callback, errback) => {\n            if (this._closed)\n                return errback(new errors_1.InvalidStateError('closed'));\n            this._handler.getSenderStats(producer.localId)\n                .then(callback)\n                .catch(errback);\n        });\n    }\n    handleConsumer(consumer) {\n        consumer.on('@close', () => {\n            this._consumers.delete(consumer.id);\n            this._pendingPauseConsumers.delete(consumer.id);\n            this._pendingResumeConsumers.delete(consumer.id);\n            if (this._closed)\n                return;\n            // Store the Consumer into the close list.\n            this._pendingCloseConsumers.set(consumer.id, consumer);\n            // There is no Consumer close in progress, do it now.\n            if (this._consumerCloseInProgress === false) {\n                this.closePendingConsumers();\n            }\n        });\n        consumer.on('@pause', () => {\n            // If Consumer is pending to be resumed, remove from pending resume list.\n            if (this._pendingResumeConsumers.has(consumer.id)) {\n                this._pendingResumeConsumers.delete(consumer.id);\n            }\n            // Store the Consumer into the pending list.\n            this._pendingPauseConsumers.set(consumer.id, consumer);\n            // There is no Consumer pause in progress, do it now.\n            if (this._consumerPauseInProgress === false) {\n                this.pausePendingConsumers();\n            }\n        });\n        consumer.on('@resume', () => {\n            // If Consumer is pending to be paused, remove from pending pause list.\n            if (this._pendingPauseConsumers.has(consumer.id)) {\n                this._pendingPauseConsumers.delete(consumer.id);\n            }\n            // Store the Consumer into the pending list.\n            this._pendingResumeConsumers.set(consumer.id, consumer);\n            // There is no Consumer resume in progress, do it now.\n            if (this._consumerResumeInProgress === false) {\n                this.resumePendingConsumers();\n            }\n        });\n        consumer.on('@getstats', (callback, errback) => {\n            if (this._closed)\n                return errback(new errors_1.InvalidStateError('closed'));\n            this._handler.getReceiverStats(consumer.localId)\n                .then(callback)\n                .catch(errback);\n        });\n    }\n    handleDataProducer(dataProducer) {\n        dataProducer.on('@close', () => {\n            this._dataProducers.delete(dataProducer.id);\n        });\n    }\n    handleDataConsumer(dataConsumer) {\n        dataConsumer.on('@close', () => {\n            this._dataConsumers.delete(dataConsumer.id);\n        });\n    }\n}\nexports.Transport = Transport;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}